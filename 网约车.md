司乘同显
高德的服务，比较贵

| 乘客           | 司机         |
| -------------- | ------------ |
| 呼叫用车       | 出车         |
| 等待司机接单   | 接单         |
|                | 到达约定地点 |
| 司乘同显       | 发起收款     |
| 跳转支付宝付款 |              |

## 项目概述

**1、逸品专车项目**
**项目描述**：
此项目是一款网约车软件，主要功能包括：

乘客端：登录注册，下单，支付，评价，推护个人信息等。

司机端：台录。出车收车，接乘客到订单完成，发起收款等。

车载大屏：同步司机和乘客信息，广告投放，第三方应用投放。

车机端：类似司机端功能，区别是在车机上操作，

项目中职责：业务需求评审，协议制定，服务端板架搭建，架构设计，技术选型，核心功能实现。

1、独自完成注册中心优化，节省了服务的上下找时间，降低了无效服务的调用率，提高了接口调用的成功率。

2、review代码时，提升了10倍效率。

**功能：**
1、地图模块：主要是接入第方地图实现，4车辆同步，辆调度，里程查询，轨透点查询，路径规划，距离计算，围栏限定等。
2、消息模块：轮寻消息，推送，短信等。
3、派单引象：实时单派单，预约单派单，抢单等。
4、订单系统：订单创建，修改，状态变史等。
5、计价系统：基础计价，动态调价，分时段计价。
6、支付系统：接入微信支付，支付宝支付。余额充值，资会漆结，订单退款等。
7、账号系统；乘客注册求，乘客信息推护。司机求入，司机录，司机信息推护等。



## 服务拆分

### 业务层

| 模块     | 项目名           | 描述 |
| -------- | ---------------- | ---- |
| 乘客端   | api-passenger    |      |
| 司机端   | api-driver       |      |
| 司机听单 | api-listen-order |      |

### 能力层

| 模块         | 项目名                    |
| ------------ | ------------------------- |
| app升级      | service-app-update        |
| 订单         | service-order             |
| 派单         | service-order-dispatch    |
| 乘客用户管理 | service-passenger-user    |
| 短信         | service-sms               |
| 计价         | service-valuation         |
| 验证码       | service-verification-code |
| 钱包         | service-wallet            |
| 支付         | service-payment           |

### 基础common

所有服务都引用的二方库

| 模块                  | 项目名          |
| --------------------- | --------------- |
| 通用,工具类,异常,校验 | internal-common |



### spring cloud基础

| 模块         | 项目名                  |
| ------------ | ----------------------- |
| 注册中心     | cloud-eureka            |
| 配置中心     | cloud-config-server     |
| 网关         | cloud-zuul              |
| 熔断监控(ui) | cloud-hystrix-dashboard |
| 健康检查     | cloud-admin             |
| 链路追踪     | cloud-zipkin-ui         |







## 架构

架构，模式，拆分，隔离，目标：**隔离系统的变化点**。

### 具体原则：

高内聚，低糊合。
高度自治：开发，测试，构建，部署，运行，发布。（无状态）
以业务为中心。
弹性设计。（容错，隔离，降级）。
自动化。持续集成，持续交付。

粒度把控：没有标准。任何一个服务，不要因为自己的开发和维护，影响其他服务。

api组，service组

业务层，能力层



### AKF



### 乘客端

1.发送验证码。
三挡验证。技术人员防止恶意发短信。
2.登录/注册。
3.查看开通区域
高德围栏
4.预估价格。
5.下单
6.（司机流程）
7.支付
8.评价。

### 司机端

1.发送验证码
2.登录，注册
3.查看，改变司机状态。
4.司机抢单（分布式锁）
5.订单状态变更。
6.发起收款





![架构图](E:\deng\deng\MD\image\didi\架构图.png)



### 包装

包装：云云。商务都来公司，跟我们技术做个交流，我们也了解他们怎么。技术情况，和我们业务结合是否匹配，开发是否易用，稳定，。。XXX。



qps:2000

### 接口设计



重在：资源。
协议：https.ios只能用https（？）.
域名：/restapi.yuming.com/
版本：1路径：/xxoo/xxoo/（名词）
动作：
	post：新建
	put：修改（修改后的全量数据） 
	patch：修改（改哪个，传哪个）
	delete：删除
	get：查询





### 安全

三级等保

**CIA**：保密性，完整性，可用性

私密数据脱敏。

**数据层面**：sql注入

jsoup框架过滤接口

#### xss,csrf

spring-htmlUtils



#### 数据权限控制



## 微服务



公司maven私服

两个服务会调用同一个Bean，那就把它抽象到common层，避免重复创建



### 异常

dao层：不打日志，catch

service：打日志，详细信息。时间，参数，

controller：异常包装成状态码。T



## 搭建

### 配置项目

* 新建maven，删除pom外的其它

* 搭服务端
  
  * new module->spring init(cloud-eureka)
    
  * 勾选developer tools下的Lombok
  
  * Spring Cloud Discover下Eureka Server
  
  * 添加@EnableEurekaServer注解
  
  * ```yml
    #server:
    #port: 7900
    spring:
      application:
        name: EurekaServer
    eureka:
      instance:
    #    prefer-ip-address: true
    #    ip-address: 127.0.0.1
      client:
        register-with-eureka: true
        fetch-registry: true
        service-url:
          defaultZone: http://eureka-7900:7900/eureka/,http://eureka-7901:7901/eureka/,http://eureka-7902:7902/eureka/
      server:
        #自我保护
        enable-self-preservation: false
        #自我保护阈值
        renewal-percent-threshold: 0.85
        #快速下线（剔除服务时间间隔）
        eviction-interval-timer-in-ms: 1000
        #多级缓存
        use-read-only-response-cache: false
        #readWrite和readOnly同步时间间隔
        #减少同步时间也能加快发现服务的速度
        response-cache-update-interval-ms: 1000
    
    
    
    ---
    spring:
      profiles: 7901
    server:
      port: 7901
    eureka:
      instance:
        hostname: eureka-7901
    
    ---
    spring:
      profiles: 7902
    server:
      port: 7902
    eureka:
      instance:
        hostname: eureka-7902
    
    ---
    spring:
      profiles: 7900
    server:
      port: 7900
    eureka:
      instance:
        hostname: eureka-7900
    ```
  
* api-passenger(provider-passenger)

  * Lombok、Eureka Discovery、web
  * 启动主程序
  
* internal-common二方库

  * Lombok

* <version>0.0.1-SNAPSHOT</version>

  * ==实际上线的话要去掉SNAPSHOT，否则会更新新提交的东西==



### 启动过程

#### 总览

* 数据同步

  * 启动拉取服务列表

    再启动集群同步



#### 细节

1.从peer拉取注册表（peer就是配置中的Default）

2.启动定时剔除任务

3.自我保护

4.续约

5.下线

6.集群间同步

自动装配EurekaServerAutoConfiguration

@EnableEurekaServer注解的作用就是new Marker() 空类

EurekaServer启动会判断是否存在Marker()类，再开启EurekaServer



~~~java
//因为续约比较频繁，这么设计可以加快服务速度（不然还得调用实例中的time属性）
class 租约{
	long 到期time;
    long 心跳time;
    T 服务实例holder
}
~~~









### CAP

不满足C	—— 一致性

因为服务开启的时候才拉取一次，



1.三级缓存。
2.从其他peer拉取注册表。peer.int registryCount=this.registry，syncUp）.没有满足C的地方。
3.P：网络不好的情况下，还是可以拉取到注册表进行调用的。

### Eureka优化

#### server优化

* 自我保护
  * 1.阈值
    2.开关
  * 比如系数是80，也就是保护80%的节点，20个挂了，1个抖动，不会提出这个
  * 服务数量少时，服务挂了基本就是挂了，不开自我保护
    服务数量多时，服务挂了可能是网络波动，开自我保护

* 快速下线

  * Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行，使用ScheduleExecutorService则没有这个问题
  * 减少服务上下线的延时

* 三级缓存（register，readWriteCacheMap，readOnlyCacheMap）

  * 新服务注册后会让readWriteCacheMap失效

  * 后两者的数据是30s同步一次的，为了高可用

  * ```yml
    #会直接从readWriteCacheMap拿数据，并发压力不高时设置
    use-read-only-response-cache: false
    #减少同步时间也能加快发现服务的速度
    response-cache-update-interval-ms: 1000
    ```
    

* 服务更新： 先停止，再发送下线请求，因为先下线可能会续约

~~~yml
server:	
	#自我保护
    enable-self-preservation: false
    #自我保护阈值
    renewal-percent-threshold: 0.85
    #快速下线（剔除服务时间间隔）
    eviction-interval-timer-in-ms: 1000
    #多级缓存
    use-read-only-response-cache: false
    #readWrite和readOnly同步时间间隔
    #减少同步时间也能加快发现服务的速度
    response-cache-update-interval-ms: 1000
~~~



#### client优化

注册，拉取，下线，3个定时任务

* heartbeatExecutor	心跳定时任务
  * cacheRefreshTask
  * heartbeatTask
  * statusChangeListener
    * 如果自身服务有变，重新注册



* 实际工作中，要把后面的url随机打乱
  * 因为默认是访问第一个，如果都配置一样的，会使得第一个压力过大
  * eureka会相互注册，所以会共享
    因此新来服务只注册第一个，就会被全部共享

```yml
server:
  port: 8080
eureka:
  #与server交互
  client:
    service-url:
      defaultZone: http://localhost:7900/eureka/
     
    #服务表拉取间隔时间
    registry-fetch-interval-seconds: 30
    #使与注册中心无关，禁用eureka-client
    enabled: false
  instance:
    #续约时间间隔
    lease-renewal-interval-in-seconds: 30

spring:
  application:
    name: api-passenger
logging:
  level: debug
```



### 服务测算

20个服务每个服务部署5个，eureka client：100个。
1分钟200。
心跳，向server发送我们活着，一天几十万次（对server来说）

集群并没有扩大承受能力，是为了高可用



### region

减少网络延迟



## 面试问题

### 业务问题

* 需要线下运营牌照和线上运营牌照
* 用户信息需要三级等保加密，用对称加密
* 用了哪些别人的服务
  * 发短信：腾讯短信通、案例短信、华信
  * 地图    ：高德 100W
  * 踢下线：极光
* 派单到司机接单是极光做的，也可以用netty、websocket、sse
  * 乘客和司机 集成极光的sdk。消息通过极光对接
    同时也减小对服务器的压力
  * 派单到司机用 redis的kv做
    * redis发布订阅影响性能（阻塞式的）
    * mq的话需要每个司机一个通道

* 本来计价的属性都放在一起，后来拆开了



* review代码时，提升了10倍效率，以及QPS提高
  * serviceUrl:打乱顺序
  * 生成验证码的速度
* 线程数=cpu可用核数/1-阻塞系数(io密集型接近1，cpu密集型接近0)
* 先发验证码，再发短信



* 问了个刁钻的问题
  * 不为了极低概率的事件，增加研发成本。

* redis中setkey和过期时间一起写，不然不是原子操作
* redis中分布式

* 分布式事务使用seata如何补偿
  启动定时任务扫描不一样的数据



* 预估价格的时候生成订单，此时资源消耗少
  而叫车的资源耗费大
  识别热点数据
  通过预估的订单提前识别大量订单来临，准备扩容
  * 阻塞式的等
  * 数据分段加锁提高效率
  * cdn转发的优化
    * 请求量要少
    * 请求路径要短，依赖少
    * 不要单点
    * 动静分离
    * 关注热点数据
  * 用消息队列削峰
  * 网络（转发）、cpu（并发）、内存（redis..）、硬盘（mysql）
  
* 别人接口没写好的时候，我启动hystrix的，直接短路走fallback

  ~~~properties
  fallback.enabled：true
  ~~~

* acuator没设置开启所有端点

### 生活问题

* 充值类型：1：仅充值，2：充值后消费
  有些不充值不能用，导致一部分用户放弃使用

### 地图问题

* 使用火星坐标（中国国测局GCJ-02）
  地球坐标(WGS84）
  百度坐标：在火星坐标上二次加密(偏移)

  百度（AR导航）

* gps数据：用来分析司机驾驶行为
  通过轨迹判断司机驾驶是否平稳

* 有个隧道gps信号不好，轨迹出现扭曲
  wifi定位
  基站定位
  轨迹纠偏



### 简历

1、独自完成注册中心优化，节省了服务的上下线时间，降低了无效服务的调用率，提高了接口调用的成功率。
2.revikw代码的时候，提升了10倍效率，以及QPS的提高



## 提高QPS

最终提高到2000 QPS



提高并发数

1.能用多线程就多线程

2.增加各种连接数（tomcat、mysql、redis)

3.服务无状态（不处理业务），便于横向扩展，扩机器

4.让服务能力对等，（serviceUrl:打乱顺序）



减少响应时间

1.异步、流量削峰（最终一致性，比如下单成功之后发邮件，没必要及时）

2.缓存（减少db，减少IO，读多，写少）

3.数据库优化

4.大数据，分批返回

5.减少调用链（比如生成验证码的服务可以放入api-passenger中，本项目中还有其它要调用生成验证码服务，所以分开写）

6.长连接（比如司机要随时获取乘客的位置）。不要轮询(会降低并发数)



## 灰度发布

### 两层灰度

![灰度场景](E:\deng\deng\MD\image\project\灰度场景.png)

> 可能需要两层灰度规则，因为网关灰度管不到后面的服务调用

### 发布方式



**蓝绿发布：**需要2排机器

**滚动发布：**虽然节省服务器，但是当更新的服务出现问题的时候排查问题麻烦，回滚更加麻烦。

**灰度发布：**少量用户放入灰度，再逐渐增加比例。失败直接撤掉就行

![发布方式](E:\deng\deng\MD\image\project\发布方式.png)

### 操作流程

A/B test
url加版本号、请求头信息、metadata数据

1.制定灰度规则，区分哪些用户，走哪些服务？boss==后台录入规则==。
2.预制规则代码
3.修改元数据（可通过url请求改metadata数据）

在GrayFilter中写相应的规则，根据用户ID查库得到它应该匹配的版本，去和问谁是的metadata信息匹配。
用RibbonFilterContextHolder来让走不同metadata信息的微服务

> 通过后台改用户规则，通过eureka的url改metadata信息，这样就不需要重启服务了

### 网关灰度代码

DB表 common_gray_rule 反向生成实体。
自己手动复制个dao和mapper，dao继承原来的，mapper更改namespace后删掉其他的，写自己的sql语句，然后加上原来的namespace

RibbonFilterContextHolder匹配metadata

#### service-sms.yml

```yml
---
spring:
  profiles: v1

eureka:
  instance:
    metadata-map:
      version: v1
      a: a1
server:
  #服务端口
  port: 8003
---
spring:
  profiles: v2

eureka:
  instance:
    metadata-map:
      version: v2
server:
  #服务端口
  port: 8004
```

#### pom

插件

```xml
<dependency>
    <groupId>io.jmnarloch</groupId>
    <artifactId>ribbon-discovery-filter-spring-cloud-starter</artifactId>
    <version>2.1.0</version>
</dependency>
```

#### GrayFilter.java

灰度网关过滤器配置

```java
@Component
public class GrayFilter extends ZuulFilter {


    @Override
    public String filterType() {
        return FilterConstants.PRE_TYPE;
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        return false;
    }

    @Autowired
    private CommonGrayRuleDaoCustom commonGrayRuleDaoCustom;

    @Override
    public Object run() throws ZuulException {


        RequestContext currentContext = RequestContext.getCurrentContext();
        HttpServletRequest request = currentContext.getRequest();

        int userId = Integer.parseInt(request.getHeader("userId"));
        // 根据用户id 查规则  查库 v1,meata

        // 金丝雀
        if (userId == 1){
            RibbonFilterContextHolder.getCurrentContext().add("version","v1");
        // 普通用户
        }else if (userId == 2){
            RibbonFilterContextHolder.getCurrentContext().add("version","v2");
        }



        return null;
    }
}
```

### 微服务灰度乞丐版

通过AOP切面获取请求中的Authorization或是token，再解析出它对应的是哪个用户，再根据用户id去找他DB中存储的灰度信息，用这个信息去匹配后面灰度微服务的metada信息

#### 启动类

```java 
@RibbonClient(name = "service-sms",configuration = GrayRibbonConfiguration.class)
```

#### RibbonParameter.java

> ThreadLocal设置类，要有get、set方法

```java
public class RibbonParameter {
    private static final  ThreadLocal LOCAL = new ThreadLocal();

    public static<T> T get(){
        return (T)LOCAL.get();
    }


    public static<T> void  set(T t){
        LOCAL.set(t);
    }
}
```

#### GrayRibbonConfiguration

> 将自定义的灰度规则注入

```java
public class GrayRibbonConfiguration {

    //把grayRule注册当前容器中
    @Bean
    public IRule ribbonRule(){
        return new GrayRule();
    }

}
```

#### RequestAspect.java

> 切面拦截request,获取Authorization，装成map设置进RibbonParameter

```java
@Component
@Aspect
//通过切面拦截
public class RequestAspect {

    @Pointcut("execution(* com.dzp.apipassenger.controller..*Controller*.*(..))")
    private void anyMethod(){

    }

    @Before(value = "anyMethod()")
    public void before(JoinPoint joinPoint){
        //获取request
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        String version = request.getHeader("version");

        //放入请求头中的version,供灰度规则用
        HashMap<String, String> map = new HashMap<>();
        map.put("version",version);

        RibbonParameter.set(map);

    }
}
```



#### GrayRule

```java
public class GrayRule extends AbstractLoadBalancerRule {
    @Override
    public void initWithNiwsConfig(IClientConfig iClientConfig) {

    }

    @Override
    public Server choose(Object key) {
        return choose(getLoadBalancer(),key);
    }
    public Server choose(ILoadBalancer lb,Object key){
        System.out.println("灰度rule");
        Server server = null;
        while (server == null){
            //获取所有可达服务
            List<Server> reachableServers = lb.getReachableServers();
            //获取当前线程参数，用于做灰度
            Map<String,String> map = RibbonParameter.get();
            String version = "";
            if (map!=null && map.containsKey("version")){
                version = map.get("version");
            }
            System.out.println("当前的rule是"+version);
            for (int i = 0; i < reachableServers.size() ; i++) {
                server = reachableServers.get(i);
                Map<String, String> metadata = ((DiscoveryEnabledServer) server).getInstanceInfo().getMetadata();
                String version1 = metadata.get("version");
               	//这里应该收到的是Authorization，以此获得用户信息
                //根据用户信息查库得灰度规则，再和后面的metadata信息去匹配
                if (version.trim().equals(version1)) {
                    return server;
                }

            }
            server = null;
        }
        return server;
    }
}
```

### 微服务灰度轻奢版

#### pom

插件

```xml
<dependency>
    <groupId>io.jmnarloch</groupId>
    <artifactId>ribbon-discovery-filter-spring-cloud-starter</artifactId>
    <version>2.1.0</version>
</dependency>
```

#### RequestAspect.java

> 切面拦截request,获取Authorization，匹配规则后直接通过RibbonFilterContextHolder分发到灰度服务

```java
@Component
@Aspect
//通过切面拦截
public class RequestAspect {

    @Pointcut("execution(* com.dzp.apipassenger.controller..*Controller*.*(..))")
    private void anyMethod(){

    }

    @Before(value = "anyMethod()")
    public void before(JoinPoint joinPoint){
        //获取request
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        //一般情况下获取到的是token或是Authorization
		//以此解析出用户Id或tag,再查DB看它匹配什么规则
        String version = request.getHeader("version");

        //通过解析出的
        if (version.trim().equals("v1")){
            RibbonFilterContextHolder.getCurrentContext().add("version","v1");
        }else if (version.trim().equals("v2")){
            RibbonFilterContextHolder.getCurrentContext().add("version","v2");
        }
    }
}

```





## 网关

网关的本质就是过滤器
should，run，filtertype，order

### 路由规则查看

http://localhost:9100/actuator/routes

~~~pom
<dependency>
<groupId>org.springframework.boot</groupld>
<artifactld>spring-boot-starter-actuator</artifactld>
</dependency>
~~~

~~~yml
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      ##默认是never
      show-details: ALWAYS
      enabled: true
    routes:
      enabled: true
~~~





### ip过滤

### 通过网关的服务出错时怎么办



```java
@Component
public class AuthFilter extends ZuulFilter {
    @Autowired
    private RedisTemplate<String,String> redisTemplate;


/**
     * 	该过滤器是否生效*/


    @Override
    public boolean shouldFilter() {


        //获取上下文
        RequestContext requestContext = RequestContext.getCurrentContext();
        HttpServletRequest request = requestContext.getRequest();

        String uri = request.getRequestURI();
        System.out.println("来源uri："+uri);

        if (uri.equals("想要限制的url")){
            //1分钟发几次就限制
        }

        //生产中有个小技巧， 过滤器开关放在db中，目的是不重启而让过滤器生效
        //新用户有特权，有人恶意刷单,在初期不处理，后面开启这个过滤
        String s = redisTemplate.opsForValue().get("service-xx");
        if (s == "off"){
            return false;
        }

        //return false时不生效
        return true;
    }

/**
     * 	拦截后的具体业务逻辑*/


    @Override
    public Object run() throws ZuulException {
		//以下是限制ip
        System.out.println("auth拦截");
        //获取上下文（重要，贯穿所有filter,用此方法都可获得包含所有参数）
        RequestContext requestContext = RequestContext.getCurrentContext();
        HttpServletRequest request = requestContext.getRequest();

        String ipAddr = getIpAddr(request);
        //用redis的过期时间
        requestContext.setSendZuulResponse(false);


        
        //以下是鉴权
        //parseBody(request) 解析token,取出key，查redis
        String token = request.getHeader("Authorization");
        if(StringUtils.isNotBlank(token)){
            JwtInfo tokenJwtInfo = JwtUtil.parseToken(token);
            if(null != tokenJwtInfo) {
                String tokenUserId = tokenJwtInfo.getSubject();
                Long tokenIssueDate = tokenJwtInfo.getIssueDate();

                BoundValueOperations<String, String> stringStringBoundValueOperations = redisTemplate.boundValueOps(RedisKeyPrefixConstant.PASSENGER_LOGIN_TOKEN_APP_KEY_PRE + tokenUserId);
                String redisToken = stringStringBoundValueOperations.get();
                if (redisToken.equals(token)){
                    return null;
                }
            }


        }
        // 还走剩下的同级过滤器，但不向后面的服务转发
        requestContext.setSendZuulResponse(false);
        //设置为无权限
        requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());
        //提醒一下
        requestContext.setResponseBody("auth fail");


        return null;
    }

/**
     * 拦截类型，4中类型。*/


    @Override
    public String filterType() {
        //优先过滤
        return FilterConstants.PRE_TYPE;
    }
/**
     * 	值越小，越在前*/

    @Override
    public int filterOrder() {
        return -1;
    }

    //获取真实ip的工具
    private String getIpAddr(HttpServletRequest request) {
        String ip = request.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }
}
```

## 限流

预估用户量(QPS，tps)，测试，压测，再设定

![限流流程](E:\deng\deng\MD\online-taxi\限流流程.png)

### 限流方法

==令牌桶算法==

![限流方法](E:\deng\deng\MD\online-taxi\限流方法.png)

### 网关限流

```java
@Component
public class LimitFilter extends ZuulFilter {

    //必须是PRE_TYPE
    @Override
    public String filterType() {
        return FilterConstants.PRE_TYPE;
    }


    @Override
    public int filterOrder() {
        //越小优先级越高
        return -10;
    }

    @Override
    public boolean shouldFilter() {
        //这个是后面的过滤器要写的，根据limit值决定走不走
//        return (boolean) RequestContext.getCurrentContext().get("limit");

        return true;
    }

    // 2 qps(1秒  2个 请求 Query Per Second 每秒查询量)
    //为限流设置参数
    private static final RateLimiter RATE_LIMITER = RateLimiter.create(50);

    @Override
    public Object run() throws ZuulException {
        RequestContext currentContext = RequestContext.getCurrentContext();

        //这个是非阻塞的，Acquire是阻塞的
        if (RATE_LIMITER.tryAcquire()){
            System.out.println("通过");
            return null;
        }else {
            // 被流控的逻辑
            System.out.println("被限流了");
            currentContext.setSendZuulResponse(false);
            currentContext.setResponseStatusCode(HttpStatus.TOO_MANY_REQUESTS.value());
        }
        return null;
    }
}
```

### 服务限流



```java
//servlet的Filter
@Component
public class LimitFilter implements Filter{

    // 2=每秒2个；0.1 = 10秒1个
    private static final RateLimiter RATE_LIMITER = RateLimiter.create(1);

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        // 限流的业务逻辑
        if (RATE_LIMITER.tryAcquire()){
            filterChain.doFilter(servletRequest,servletResponse);
        }else {

            servletResponse.setCharacterEncoding("utf-8");
            servletResponse.setContentType("text/html; charset=utf-8");

            PrintWriter pw = null;

            pw = servletResponse.getWriter();
            pw.write("限流了");

            pw.close();


        }
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void destroy() {

    }
}
```

## 分布式事务

### seata-AT

有全局锁，TCC模式没有，因为他会在cancel中逆操作实现回滚

### seata-TCC

try、confirm、cancel

tcc主要适用于无事务的db（redis、mongodb）

**tcc场景：（!（支持acid事务的关系型数据库） 和 xxx  ）。**



吞吐量低可以选择加入消息队列，
第一个服务TM处理后直接返回，后面异步处理



## 分布式锁

redis分布式锁中

* 业务finally中会释放锁，同时锁自身也有过期时间。
  那么就可能出现业务执行超过了锁自身过期时间，再执行finally释放锁，然后释放了其它同名的锁

#### 面试用

```java
@Service("grabRedisLockService")
public class GrabRedisLockServiceImpl implements GrabService {

   @Autowired
   StringRedisTemplate stringRedisTemplate;
   
   @Autowired
   OrderService orderService;
   
    @Override
    public String grabOrder(int orderId , int driverId){
        //生成key
       String lock = "order_"+(orderId+"");
       /*
        *  情况一，如果锁没执行到释放，比如业务逻辑执行一半，运维重启服务，或 服务器挂了，没走 finally，怎么办？
        *  加超时时间
        *  setnx
        */
//     boolean lockStatus = stringRedisTemplate.opsForValue().setIfAbsent(lock.intern(), driverId+"");
//     if(!lockStatus) {
//        return null;
//     }
       
       /*
        *  情况二：加超时时间,会有加不上的情况，运维重启
        */
//     boolean lockStatus = stringRedisTemplate.opsForValue().setIfAbsent(lock.intern(), driverId+"");
//     stringRedisTemplate.expire(lock.intern(), 30L, TimeUnit.SECONDS);
//     if(!lockStatus) {
//        return null;
//     }
       
       /*
        * 情况三：超时时间应该一次加，不应该分2行代码，
        * 
        */
       boolean lockStatus = stringRedisTemplate.opsForValue().setIfAbsent(lock.intern(), driverId+"", 30L, TimeUnit.SECONDS);
       // 开个子线程，原来时间N，每个n/3，去续上n
       
       if(!lockStatus) {
          return null;
       }
       
       try {
         System.out.println("司机:"+driverId+" 执行抢单逻辑");
         
            boolean b = orderService.grab(orderId, driverId);
            if(b) {
               System.out.println("司机:"+driverId+" 抢单成功");
            }else {
               System.out.println("司机:"+driverId+" 抢单失败");
            }
            
        } finally {
           /**
            * 这种释放锁有，可能释放了别人的锁。
            */
//         stringRedisTemplate.delete(lock.intern());
           
           /**
            * 下面代码避免释放别人的锁
            */
           if((driverId+"").equals(stringRedisTemplate.opsForValue().get(lock.intern()))) {
            stringRedisTemplate.delete(lock.intern());
         }
        }
        return null;
    }
}
```

# 实操

## 功能列表

### 用户登录

 ![登录服务](E:\deng\deng\MD\online-taxi\登录服务.png)

#### 大体流程

创建各项目，测试，配置yml,

api-passenger和service-verification-code都需要的参数抽象到common中

生成验证码，用户输入后点确定，校验验证码，

#### application.yml

~~~yml
server:
	port: 8081
eureka:
	client: 
		enabled: false
spring:
	application:
		name: service
~~~

#### 接口设计

把service整得更通用一些，因为即使同一个手机号有可能有多种身份

==sms封装的参数在这里==

![接口设计](E:\deng\deng\MD\online-taxi\接口设计.png)



### 消息队列+时间表做分布式事务

service-order
service-pay

注意启动类注解

## 开发技巧

* controller接入RequestBody，然后提取出其中的有用信息（如phoneNumber）,传入service中执行业务（service只需要number就行了）
* 外部请求先打到网关，需要鉴权，网关再调用业务的时候就不用反复鉴权
* **注释引起编码错误**

* 本地db操作先行，调用其它系统在后，方便回滚（可控性排序）

## 代码技巧

### 实体对象转成Map

```java
/**
 * 实体对象转成Map
 *
 * @param obj 实体对象
 * @return
 */
public static Map<String, Object> object2Map(Object obj) {
    Map<String, Object> map = new HashMap<>(281);
    if (obj == null) {
        return map;
    }
    Class clazz = obj.getClass();
    Field[] fields = clazz.getDeclaredFields();
    try {
        for (Field field : fields) {
            field.setAccessible(true);
            map.put(field.getName(), field.get(obj));
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return map;
}
```

### BigDecimal

BigDecimal计算价格，用来对超过16位有效位的数进行精确的运算， BigDecimal所创建的是
对象，故我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。

### Json使用

```java
if (responseResult.getCode() == CommonStatusEnum.SUCCESS.getCode()){
    //获取json格式的验证码
    JSONObject data = JSONObject.fromObject(responseResult.getData().toString());
    //==JSON用法-验证码转为VerifyCodeResponse
    verifyCodeResponse = (VerifyCodeResponse)JSONObject.toBean(data,VerifyCodeResponse.class);
}else {
    return ResponseResult.fail("获取验证码失败");
}
```

### Redis

存两分钟

```java
//set和过期时间放一起，否则不是原子操作，服务器中间挂了，就只存不过期了
BoundValueOperations<String, String> codeRedis = redisTemplate.boundValueOps(key);
codeRedis.set(code,2,TimeUnit.MICROSECONDS);
```



## 开发中出现的问题

* 用户的时间跟服务器的时间不一样，需要同步时间
* 有旅游团刷单，不给钱
* 假派单成功
  * 设置空闲司机数量，如果超过这个数量，给用户假派单成功，转人工派单。
    防止用户通过规则没有匹配上车辆
* 派单中的规则是boss端写进数据库的，应用规则时到数据库里取，如多少公里内派单，前后时间间隔等等。

### enum类

```java
public class RedisKeyPrefixConstant {
   /**
    * 乘客登录验证码 key前缀
    */
   public static final String PASSENGER_LOGIN_CODE_KEY_PRE = "passenger_login_code_";

   public static final String PASSENGER_LOGIN_TOKEN_APP_KEY_PRE = "passenger_login_token_app_";

   public static final String PASSENGER_LOGIN_TOKEN_WEIXIN_KEY_PRE = "passenger_login_token_weixin_";

   /**
    * 司机登录验证码 key前缀
    */
   public static final String DRIVER_LOGIN_CODE_KEY_PRE = "driver_login_code_";


}
```

### 判断String为空

```java
StringUtils.isNotBlank()
```

## 架构完成后，需要练习的点

* 存入redis
* 收藏常用路线，存库
* 地图围栏服务（map-service）
* 

# 开发实用技巧

## redis

存redis

```java
    /**
     * 从缓存中设置计价对象
     *
     * @param orderId    订单ID
     * @param priceMeter 计价对象
     * @param timeout    过期时间
     * @param unit       过期时间单位
     */
public void set(Integer orderId, PriceMeter priceMeter, long timeout, TimeUnit unit) {
    String key = generateKey(orderId);
    log.info("设置缓存orderId={}, PriceMeterInRedis={}", orderId, key);
    try {
        //将类转换为json字符串
        redisTemplate.opsForValue().set(key, mapper.writeValueAsString(priceMeter), timeout, unit);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
    }
}
/**
     * 生成redis的key
     *
     * @param orderId 订单ID
     * @return redis的key
     */
    private String generateKey(Integer orderId) {
        return String.format("%s:%s:%s", OrderRuleNames.PREFIX, OrderRuleNames.PRICE, orderId);
    }
```

## 类、Json格式转换

```java
ObjectMapper objectMapper = new ObjectMapper();
rule = objectMapper.readValue(ruleJson, Rule.class);
```

## 日志

```java
log.info("orderId={}, RuleJson={}", orderId, ruleJson);
```

```java
log.error("orderId={}, 解析RuleJson错误:", orderId, e);
```

## **使用Optional优化代码**

```java
public` `static` `String getUserNameByOptional(User user) {``  ``Optional<String> userName = Optional.ofNullable(user).map(User::getName);``  ``return` `userName.orElse(``null``);``}
```

## 通用枚举类

 return 字符串格式的code值

```java
public interface CodeEnum {

    /**
     * 返回枚举体的code值
     *
     * @return code值
     */
    int getCode();

    /**
     * 返回枚举体的code值
     *
     * @return 字符串格式的code值
     */
    default String getCodeAsString() {
        return "" + getCode();
    }
}
```



## mybatyis.xml变动

看灰度发布-网关灰度
cloud-zuul里的例子

## copy代码出错

xml的namespace没改

# 需要问人的点

计价服务中OrderRuleMirrorDao，为什么要这么一个镜像。

entity是反向生成的

requestTask干什么用，并没有请求打进来，怎么用。

TCC测试中mapper.xml中的insert语句中还有selectKey

