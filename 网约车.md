司乘同显
高德的服务，比较贵

| 乘客           | 司机         |
| -------------- | ------------ |
| 呼叫用车       | 出车         |
| 等待司机接单   | 接单         |
|                | 到达约定地点 |
| 司乘同显       | 发起收款     |
| 跳转支付宝付款 |              |

## 项目概述

**1、逸品专车项目**
**项目描述**：
此项目是一款网约车软件，主要功能包括：

乘客端：登录注册，下单，支付，评价，推护个人信息等。

司机端：台录。出车收车，接乘客到订单完成，发起收款等。

车载大屏：同步司机和乘客信息，广告投放，第三方应用投放。

车机端：类似司机端功能，区别是在车机上操作，

项目中职责：业务需求评审，协议制定，服务端板架搭建，架构设计，技术选型，核心功能实现。

1、独自完成注册中心优化，节省了服务的上下找时间，降低了无效服务的调用率，提高了接口调用的成功率。

2、review代码时，提升了10倍效率。

**功能：**
1、地图模块：主要是接入第方地图实现，4车辆同步，辆调度，里程查询，轨透点查询，路径规划，距离计算，围栏限定等。
2、消息模块：轮寻消息，推送，短信等。
3、派单引象：实时单派单，预约单派单，抢单等。
4、订单系统：订单创建，修改，状态变史等。
5、计价系统：基础计价，动态调价，分时段计价。
6、支付系统：接入微信支付，支付宝支付。余额充值，资会漆结，订单退款等。
7、账号系统；乘客注册求，乘客信息推护。司机求入，司机录，司机信息推护等。



## 服务拆分

### 业务层

| 模块     | 项目名           | 描述 |
| -------- | ---------------- | ---- |
| 乘客端   | api-passenger    |      |
| 司机端   | api-driver       |      |
| 司机听单 | api-listen-order |      |

### 能力层

| 模块         | 项目名                    |
| ------------ | ------------------------- |
| app升级      | service-app-update        |
| 订单         | service-order             |
| 派单         | service-order-dispatch    |
| 乘客用户管理 | service-passenger-user    |
| 短信         | service-sms               |
| 计价         | service-valuation         |
| 验证码       | service-verification-code |
| 钱包         | service-wallet            |
| 支付         | service-payment           |

### 基础common

所有服务都引用的二方库

| 模块                  | 项目名          |
| --------------------- | --------------- |
| 通用,工具类,异常,校验 | internal-common |



### spring cloud基础

| 模块         | 项目名                  |
| ------------ | ----------------------- |
| 注册中心     | cloud-eureka            |
| 配置中心     | cloud-config-server     |
| 网关         | cloud-zuul              |
| 熔断监控(ui) | cloud-hystrix-dashboard |
| 健康检查     | cloud-admin             |
| 链路追踪     | cloud-zipkin-ui         |







## 架构

架构，模式，拆分，隔离，目标：**隔离系统的变化点**。

### 具体原则：

高内聚，低糊合。
高度自治：开发，测试，构建，部署，运行，发布。（无状态）
以业务为中心。
弹性设计。（容错，隔离，降级）。
自动化。持续集成，持续交付。

粒度把控：没有标准。任何一个服务，不要因为自己的开发和维护，影响其他服务。

api组，service组

业务层，能力层



### AKF



### 乘客端

1.发送验证码。
三挡验证。技术人员防止恶意发短信。
2.登录/注册。
3.查看开通区域
高德围栏
4.预估价格。
5.下单
6.（司机流程）
7.支付
8.评价。

### 司机端

1.发送验证码
2.登录，注册
3.查看，改变司机状态。
4.司机抢单（分布式锁）
5.订单状态变更。
6.发起收款





![架构图](E:\deng\deng\MD\image\didi\架构图.png)



### 包装

包装：云云。商务都来公司，跟我们技术做个交流，我们也了解他们怎么。技术情况，和我们业务结合是否匹配，开发是否易用，稳定，。。XXX。



qps:2000

### 接口设计



重在：资源。
协议：https.ios只能用https（？）.
域名：/restapi.yuming.com/
版本：1路径：/xxoo/xxoo/（名词）
动作：
	post：新建
	put：修改（修改后的全量数据） 
	patch：修改（改哪个，传哪个）
	delete：删除
	get：查询





### 安全

三级等保

**CIA**：保密性，完整性，可用性

私密数据脱敏。

**数据层面**：sql注入

jsoup框架过滤接口

#### xss,csrf

spring-htmlUtils



#### 数据权限控制



## 微服务



公司maven私服

两个服务会调用同一个Bean，那就把它抽象到common层，避免重复创建



### 异常

dao层：不打日志，catch

service：打日志，详细信息。时间，参数，

controller：异常包装成状态码。T



## 搭建

### 配置项目

* 新建maven，删除pom外的其它

* 搭服务端
  
  * new module->spring init(cloud-eureka)
    
  * 勾选developer tools下的Lombok
  
  * Spring Cloud Discover下Eureka Server
  
  * 添加@EnableEurekaServer注解
  
  * ```yml
    #server:
    #port: 7900
    spring:
      application:
        name: EurekaServer
    eureka:
      instance:
    #    prefer-ip-address: true
    #    ip-address: 127.0.0.1
      client:
        register-with-eureka: true
        fetch-registry: true
        service-url:
          defaultZone: http://eureka-7900:7900/eureka/,http://eureka-7901:7901/eureka/,http://eureka-7902:7902/eureka/
      server:
        #自我保护
        enable-self-preservation: false
        #自我保护阈值
        renewal-percent-threshold: 0.85
        #快速下线（剔除服务时间间隔）
        eviction-interval-timer-in-ms: 1000
        #多级缓存
        use-read-only-response-cache: false
        #readWrite和readOnly同步时间间隔
        #减少同步时间也能加快发现服务的速度
        response-cache-update-interval-ms: 1000
    
    
    
    ---
    spring:
      profiles: 7901
    server:
      port: 7901
    eureka:
      instance:
        hostname: eureka-7901
    
    ---
    spring:
      profiles: 7902
    server:
      port: 7902
    eureka:
      instance:
        hostname: eureka-7902
    
    ---
    spring:
      profiles: 7900
    server:
      port: 7900
    eureka:
      instance:
        hostname: eureka-7900
    ```
  
* api-passenger(provider-passenger)

  * Lombok、Eureka Discovery、web
  * 启动主程序
  
* internal-common二方库

  * Lombok

* <version>0.0.1-SNAPSHOT</version>

  * ==实际上线的话要去掉SNAPSHOT，否则会更新新提交的东西==



### 启动过程

#### 总览

* 数据同步

  * 启动拉取服务列表

    再启动集群同步



#### 细节

1.从peer拉取注册表（peer就是配置中的Default）

2.启动定时剔除任务

3.自我保护

4.续约

5.下线

6.集群间同步

自动装配EurekaServerAutoConfiguration

@EnableEurekaServer注解的作用就是new Marker() 空类

EurekaServer启动会判断是否存在Marker()类，再开启EurekaServer



~~~java
//因为续约比较频繁，这么设计可以加快服务速度（不然还得调用实例中的time属性）
class 租约{
	long 到期time;
    long 心跳time;
    T 服务实例holder
}
~~~









### CAP

不满足C	—— 一致性

因为服务开启的时候才拉取一次，



1.三级缓存。
2.从其他peer拉取注册表。peer.int registryCount=this.registry，syncUp）.没有满足C的地方。
3.P：网络不好的情况下，还是可以拉取到注册表进行调用的。

### Eureka优化

#### server优化

* 自我保护
  * 1.阈值
    2.开关
  * 比如系数是80，也就是保护80%的节点，20个挂了，1个抖动，不会提出这个
  * 服务数量少时，服务挂了基本就是挂了，不开自我保护
    服务数量多时，服务挂了可能是网络波动，开自我保护

* 快速下线

  * Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行，使用ScheduleExecutorService则没有这个问题
  * 减少服务上下线的延时

* 三级缓存（register，readWriteCacheMap，readOnlyCacheMap）

  * 新服务注册后会让readWriteCacheMap失效

  * 后两者的数据是30s同步一次的，为了高可用

  * ```yml
    #会直接从readWriteCacheMap拿数据，并发压力不高时设置
    use-read-only-response-cache: false
    #减少同步时间也能加快发现服务的速度
    response-cache-update-interval-ms: 1000
    ```
    

* 服务更新： 先停止，再发送下线请求，因为先下线可能会续约

~~~yml
server:	
	#自我保护
    enable-self-preservation: false
    #自我保护阈值
    renewal-percent-threshold: 0.85
    #快速下线（剔除服务时间间隔）
    eviction-interval-timer-in-ms: 1000
    #多级缓存
    use-read-only-response-cache: false
    #readWrite和readOnly同步时间间隔
    #减少同步时间也能加快发现服务的速度
    response-cache-update-interval-ms: 1000
~~~



#### client优化

注册，拉取，下线，3个定时任务

* heartbeatExecutor	心跳定时任务
  * cacheRefreshTask
  * heartbeatTask
  * statusChangeListener
    * 如果自身服务有变，重新注册



* 实际工作中，要把后面的url随机打乱
  * 因为默认是访问第一个，如果都配置一样的，会使得第一个压力过大
  * eureka会相互注册，所以会共享
    因此新来服务只注册第一个，就会被全部共享

```yml
server:
  port: 8080
eureka:
  #与server交互
  client:
    service-url:
      defaultZone: http://localhost:7900/eureka/
     
    #服务表拉取间隔时间
    registry-fetch-interval-seconds: 30
    #使与注册中心无关，禁用eureka-client
    enabled: false
  instance:
    #续约时间间隔
    lease-renewal-interval-in-seconds: 30

spring:
  application:
    name: api-passenger
logging:
  level: debug
```



### 服务测算

20个服务每个服务部署5个，eureka client：100个。
1分钟200。
心跳，向server发送我们活着，一天几十万次（对server来说）

集群并没有扩大承受能力，是为了高可用



### region

减少网络延迟



## 面试问题

### 业务问题

* 需要线下运营牌照和线上运营牌照
* 用户信息需要三级等保加密，用对称加密
* 用了哪些别人的服务
  * 发短信：腾讯短信通、案例短信、华信
  * 地图    ：高德 100W
  * 踢下线：极光
  * 号码：阿里的隐私号，AB联系通过中间号码
* 派单到司机接单是极光做的，也可以用netty、websocket、sse
  * 乘客和司机 集成极光的sdk。消息通过极光对接
    同时也减小对服务器的压力
  * 派单到司机用 redis的kv做
    * redis发布订阅影响性能（阻塞式的）
    * mq的话需要每个司机一个通道

* 本来计价的属性都放在一起，后来拆开了



* 用户的头像啊什么的传到oss,自己的系统只存资源的url



* review代码时，提升了10倍效率，以及QPS提高
  * serviceUrl:打乱顺序
  * 生成验证码的速度
* 线程数=cpu可用核数/1-阻塞系数(io密集型接近1，cpu密集型接近0)
* 先发验证码，再发短信



* 问了个刁钻的问题
  * 不为了极低概率的事件，增加研发成本。

* redis中setkey和过期时间一起写，不然不是原子操作
* redis中分布式

* 分布式事务使用seata如何补偿
  启动定时任务扫描不一样的数据



* 预估价格的时候生成订单，此时资源消耗少
  而叫车的资源耗费大
  识别热点数据
  通过预估的订单提前识别大量订单来临，准备扩容
  * 阻塞式的等
  * 数据分段加锁提高效率
  * cdn转发的优化
    * 请求量要少
    * 请求路径要短，依赖少
    * 不要单点
    * 动静分离
    * 关注热点数据
  * 用消息队列削峰
  * 网络（转发）、cpu（并发）、内存（redis..）、硬盘（mysql）
  
* 别人接口没写好的时候，我启动hystrix的，直接短路走fallback

  ~~~properties
  fallback.enabled：true
  ~~~

* acuator没设置开启所有端点

### 闲聊问题

* 需要审批，安全及运维方面，会让第三方安全公司去检查。
  还要通过连通性测试和符合性测试

* 网约车数据要向国家上报
  * 业务数据都要传到国家监管平台，因此用消息队列上报，通过上报系统去做。
  * 文件要求是实时位置追踪，但我们也是尽量不影响我们的业务，所以也是用消息队列做的

* 

* 充值类型：1：仅充值，2：充值后消费
  有些不充值不能用，导致一部分用户放弃使用
* 三方传来的信息最好保留，即使三方很可靠
* 一个事务中，本地DB在三方操作前，这样如果3方出错可以回滚自己的事务。
  反过来的话，三方成功而我方DB失败则无法回滚三方




* 产品经理打电话给滴滴客服，询问详细退款流程



### 简历

1、独自完成注册中心优化，节省了服务的上下线时间，降低了无效服务的调用率，提高了接口调用的成功率。
2.revikw代码的时候，提升了10倍效率，以及QPS的提高



## 提高QPS

最终提高到2000 QPS



提高并发数

1.能用多线程就多线程

2.增加各种连接数（tomcat、mysql、redis)

3.服务无状态（不处理业务），便于横向扩展，扩机器

4.让服务能力对等，（serviceUrl:打乱顺序）



减少响应时间

1.异步、流量削峰（最终一致性，比如下单成功之后发邮件，没必要及时）

2.缓存（减少db，减少IO，读多，写少）

3.数据库优化

4.大数据，分批返回

5.减少调用链（比如生成验证码的服务可以放入api-passenger中，本项目中还有其它要调用生成验证码服务，所以分开写）

6.长连接（比如司机要随时获取乘客的位置）。不要轮询(会降低并发数)



## 灰度发布

### 两层灰度

![灰度场景](E:\deng\deng\MD\image\project\灰度场景.png)

> 可能需要两层灰度规则，因为网关灰度管不到后面的服务调用

### 发布方式



**蓝绿发布：**需要2排机器

**滚动发布：**虽然节省服务器，但是当更新的服务出现问题的时候排查问题麻烦，回滚更加麻烦。

**灰度发布：**少量用户放入灰度，再逐渐增加比例。失败直接撤掉就行

![发布方式](E:\deng\deng\MD\image\project\发布方式.png)

### 操作流程

A/B test
url加版本号、请求头信息、metadata数据

1.制定灰度规则，区分哪些用户，走哪些服务？boss==后台录入规则==。
2.预制规则代码
3.修改元数据（可通过url请求改metadata数据）

在GrayFilter中写相应的规则，根据用户ID查库得到它应该匹配的版本，去和问谁是的metadata信息匹配。
用RibbonFilterContextHolder来让走不同metadata信息的微服务

> 通过后台改用户规则，通过eureka的url改metadata信息，这样就不需要重启服务了

### 网关灰度代码

DB表 common_gray_rule 反向生成实体。
自己手动复制个dao和mapper，dao继承原来的，mapper更改namespace后删掉其他的，写自己的sql语句，然后加上原来的namespace

RibbonFilterContextHolder匹配metadata

#### service-sms.yml

```yml
---
spring:
  profiles: v1

eureka:
  instance:
    metadata-map:
      version: v1
      a: a1
server:
  #服务端口
  port: 8003
---
spring:
  profiles: v2

eureka:
  instance:
    metadata-map:
      version: v2
server:
  #服务端口
  port: 8004
```

#### pom

插件

```xml
<dependency>
    <groupId>io.jmnarloch</groupId>
    <artifactId>ribbon-discovery-filter-spring-cloud-starter</artifactId>
    <version>2.1.0</version>
</dependency>
```

#### GrayFilter.java

灰度网关过滤器配置

```java
@Component
public class GrayFilter extends ZuulFilter {


    @Override
    public String filterType() {
        return FilterConstants.PRE_TYPE;
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        return false;
    }

    @Autowired
    private CommonGrayRuleDaoCustom commonGrayRuleDaoCustom;

    @Override
    public Object run() throws ZuulException {


        RequestContext currentContext = RequestContext.getCurrentContext();
        HttpServletRequest request = currentContext.getRequest();

        int userId = Integer.parseInt(request.getHeader("userId"));
        // 根据用户id 查规则  查库 v1,meata

        // 金丝雀
        if (userId == 1){
            RibbonFilterContextHolder.getCurrentContext().add("version","v1");
        // 普通用户
        }else if (userId == 2){
            RibbonFilterContextHolder.getCurrentContext().add("version","v2");
        }



        return null;
    }
}
```

### 微服务灰度乞丐版

通过AOP切面获取请求中的Authorization或是token，再解析出它对应的是哪个用户，再根据用户id去找他DB中存储的灰度信息，用这个信息去匹配后面灰度微服务的metada信息

#### 启动类

```java 
@RibbonClient(name = "service-sms",configuration = GrayRibbonConfiguration.class)
```

#### RibbonParameter.java

> ThreadLocal设置类，要有get、set方法

```java
public class RibbonParameter {
    private static final  ThreadLocal LOCAL = new ThreadLocal();

    public static<T> T get(){
        return (T)LOCAL.get();
    }


    public static<T> void  set(T t){
        LOCAL.set(t);
    }
}
```

#### GrayRibbonConfiguration

> 将自定义的灰度规则注入

```java
public class GrayRibbonConfiguration {

    //把grayRule注册当前容器中
    @Bean
    public IRule ribbonRule(){
        return new GrayRule();
    }

}
```

#### RequestAspect.java

> 切面拦截request,获取Authorization，装成map设置进RibbonParameter

```java
@Component
@Aspect
//通过切面拦截
public class RequestAspect {

    @Pointcut("execution(* com.dzp.apipassenger.controller..*Controller*.*(..))")
    private void anyMethod(){

    }

    @Before(value = "anyMethod()")
    public void before(JoinPoint joinPoint){
        //获取request
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        String version = request.getHeader("version");

        //放入请求头中的version,供灰度规则用
        HashMap<String, String> map = new HashMap<>();
        map.put("version",version);

        RibbonParameter.set(map);

    }
}
```



#### GrayRule

```java
public class GrayRule extends AbstractLoadBalancerRule {
    @Override
    public void initWithNiwsConfig(IClientConfig iClientConfig) {

    }

    @Override
    public Server choose(Object key) {
        return choose(getLoadBalancer(),key);
    }
    public Server choose(ILoadBalancer lb,Object key){
        System.out.println("灰度rule");
        Server server = null;
        while (server == null){
            //获取所有可达服务
            List<Server> reachableServers = lb.getReachableServers();
            //获取当前线程参数，用于做灰度
            Map<String,String> map = RibbonParameter.get();
            String version = "";
            if (map!=null && map.containsKey("version")){
                version = map.get("version");
            }
            System.out.println("当前的rule是"+version);
            for (int i = 0; i < reachableServers.size() ; i++) {
                server = reachableServers.get(i);
                Map<String, String> metadata = ((DiscoveryEnabledServer) server).getInstanceInfo().getMetadata();
                String version1 = metadata.get("version");
               	//这里应该收到的是Authorization，以此获得用户信息
                //根据用户信息查库得灰度规则，再和后面的metadata信息去匹配
                if (version.trim().equals(version1)) {
                    return server;
                }

            }
            server = null;
        }
        return server;
    }
}
```

### 微服务灰度轻奢版

#### pom

插件

```xml
<dependency>
    <groupId>io.jmnarloch</groupId>
    <artifactId>ribbon-discovery-filter-spring-cloud-starter</artifactId>
    <version>2.1.0</version>
</dependency>
```

#### RequestAspect.java

> 切面拦截request,获取Authorization，匹配规则后直接通过RibbonFilterContextHolder分发到灰度服务

```java
@Component
@Aspect
//通过切面拦截
public class RequestAspect {

    @Pointcut("execution(* com.dzp.apipassenger.controller..*Controller*.*(..))")
    private void anyMethod(){

    }

    @Before(value = "anyMethod()")
    public void before(JoinPoint joinPoint){
        //获取request
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        //一般情况下获取到的是token或是Authorization
		//以此解析出用户Id或tag,再查DB看它匹配什么规则
        String version = request.getHeader("version");

        //通过解析出的
        if (version.trim().equals("v1")){
            RibbonFilterContextHolder.getCurrentContext().add("version","v1");
        }else if (version.trim().equals("v2")){
            RibbonFilterContextHolder.getCurrentContext().add("version","v2");
        }
    }
}

```





## 网关

网关的本质就是过滤器
should，run，filtertype，order

### 路由规则查看

http://localhost:9100/actuator/routes

~~~pom
<dependency>
<groupId>org.springframework.boot</groupld>
<artifactld>spring-boot-starter-actuator</artifactld>
</dependency>
~~~

~~~yml
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      ##默认是never
      show-details: ALWAYS
      enabled: true
    routes:
      enabled: true
~~~





### ip过滤

### 通过网关的服务出错时怎么办



```java
@Component
public class AuthFilter extends ZuulFilter {
    @Autowired
    private RedisTemplate<String,String> redisTemplate;


/**
     * 	该过滤器是否生效*/


    @Override
    public boolean shouldFilter() {


        //获取上下文
        RequestContext requestContext = RequestContext.getCurrentContext();
        HttpServletRequest request = requestContext.getRequest();

        String uri = request.getRequestURI();
        System.out.println("来源uri："+uri);

        if (uri.equals("想要限制的url")){
            //1分钟发几次就限制
        }

        //生产中有个小技巧， 过滤器开关放在db中，目的是不重启而让过滤器生效
        //新用户有特权，有人恶意刷单,在初期不处理，后面开启这个过滤
        String s = redisTemplate.opsForValue().get("service-xx");
        if (s == "off"){
            return false;
        }

        //return false时不生效
        return true;
    }

/**
     * 	拦截后的具体业务逻辑*/


    @Override
    public Object run() throws ZuulException {
		//以下是限制ip
        System.out.println("auth拦截");
        //获取上下文（重要，贯穿所有filter,用此方法都可获得包含所有参数）
        RequestContext requestContext = RequestContext.getCurrentContext();
        HttpServletRequest request = requestContext.getRequest();

        String ipAddr = getIpAddr(request);
        //用redis的过期时间
        requestContext.setSendZuulResponse(false);


        
        //以下是鉴权
        //parseBody(request) 解析token,取出key，查redis
        String token = request.getHeader("Authorization");
        if(StringUtils.isNotBlank(token)){
            JwtInfo tokenJwtInfo = JwtUtil.parseToken(token);
            if(null != tokenJwtInfo) {
                String tokenUserId = tokenJwtInfo.getSubject();
                Long tokenIssueDate = tokenJwtInfo.getIssueDate();

                BoundValueOperations<String, String> stringStringBoundValueOperations = redisTemplate.boundValueOps(RedisKeyPrefixConstant.PASSENGER_LOGIN_TOKEN_APP_KEY_PRE + tokenUserId);
                String redisToken = stringStringBoundValueOperations.get();
                if (redisToken.equals(token)){
                    return null;
                }
            }


        }
        // 还走剩下的同级过滤器，但不向后面的服务转发
        requestContext.setSendZuulResponse(false);
        //设置为无权限
        requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());
        //提醒一下
        requestContext.setResponseBody("auth fail");


        return null;
    }

/**
     * 拦截类型，4中类型。*/


    @Override
    public String filterType() {
        //优先过滤
        return FilterConstants.PRE_TYPE;
    }
/**
     * 	值越小，越在前*/

    @Override
    public int filterOrder() {
        return -1;
    }

    //获取真实ip的工具
    private String getIpAddr(HttpServletRequest request) {
        String ip = request.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }
}
```

## 限流

预估用户量(QPS，tps)，测试，压测，再设定

![限流流程](E:\deng\deng\MD\online-taxi\限流流程.png)

### 限流方法

==令牌桶算法==

![限流方法](E:\deng\deng\MD\online-taxi\限流方法.png)

### 网关限流

RateLimiter是guava的东东

`tryAcquire`是非阻塞的，`Acquire`是阻塞的

```java
@Component
public class LimitFilter extends ZuulFilter {

    //必须是PRE_TYPE
    @Override
    public String filterType() {
        return FilterConstants.PRE_TYPE;
    }


    @Override
    public int filterOrder() {
        //越小优先级越高
        return -10;
    }

    @Override
    public boolean shouldFilter() {
        //这个是后面的过滤器要写的，根据limit值决定走不走
//        if(!(boolean) RequestContext.getCurrentContext().get("limit"))  return false;
        return true;

    }

    // 2 qps(1秒  2个 请求 Query Per Second 每秒查询量)
    //为限流设置参数
    private static final RateLimiter RATE_LIMITER = RateLimiter.create(1);

    @Override
    public Object run() throws ZuulException {
        //贯穿全局
        RequestContext currentContext = RequestContext.getCurrentContext();

        //这个是非阻塞的，Acquire是阻塞的
        if (RATE_LIMITER.tryAcquire()){
            System.out.println("通过");
            return null;
        }else {
            // 被流控的逻辑
            System.out.println("被限流了");
            //不会走下级的过滤器的，但是同级的还是会走
            currentContext.setSendZuulResponse(false);
            //让同级的也不走,设置个标识
            currentContext.set("limit",false);
            //返回请求太多的提示
            currentContext.setResponseStatusCode(HttpStatus.TOO_MANY_REQUESTS.value());
        }
        return null;
    }
}
```

### 服务限流



```java
//servlet的Filter
@Component
public class LimitFilter implements Filter{

    // 2=每秒2个；0.1 = 10秒1个
    private static final RateLimiter RATE_LIMITER = RateLimiter.create(1);

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        // 限流的业务逻辑
        if (RATE_LIMITER.tryAcquire()){
            filterChain.doFilter(servletRequest,servletResponse);
        }else {

            servletResponse.setCharacterEncoding("utf-8");
            servletResponse.setContentType("text/html; charset=utf-8");

            PrintWriter pw = null;

            pw = servletResponse.getWriter();
            pw.write("限流了");

            pw.close();


        }
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void destroy() {

    }
}
```

## 计价

### 背景

项目经理问能不能自己做，可能吗，高德一个地图都2K+人开发。
然后谈的高德和百度，两边都联系了。百度的特色是AI导航，高德接口的应用性比较好。

看高德提供的文档

https://lbs.amap.com/api/webservice/summary/

### 地图

**围栏**：FenceController
做区域限定，会提醒你是否在范围内

配置让后端来做，高德给的sid虽然基本不会变，但是你换服务的话就需要更新，因此统一交给服务端管理，否则就需要更新APP，IOS更是要审核

乘客司机用的同一个sid，定时将位置信息传给服务端，再上报给高德，由高德来调度车辆

高德有个解决方案是直接用自己的订单去匹配高德的订单，自己都不用存订单信息，最后还是没用，因为我们自己不存信息是不合适的。
因此高德的订单信息只有起点终点位置是对的，像什么开始计价位置，结束计价位置都是随便给的。

#### 问题

* 使用火星坐标（中国国测局GCJ-02）
  地球坐标(WGS84）
  百度坐标：在火星坐标上二次加密(偏移)

  百度（AR导航）

* 能测量的只有两家
  四维图新、高德

* gps数据：用来分析司机驾驶行为
  通过轨迹判断司机驾驶是否平稳
从而分配给孕妇、小孩啥的
  
* 有个隧道gps信号不好，轨迹出现扭曲，高德说我们解决不了，没人解决的了
  wifi定位
  基站定位
  轨迹纠偏

### 预估价格

当时讨论过要不要存预估信息，一部分人建议不存，觉得浪费数据库，最后为了评估信息还是存了。

用BigDecimal，注意用字符串，因为有的小数用二进制无法精准表示

### 计价规则

一般计价规则（rule）+动态调价

需要审批

### 架构设计

![计费规则](E:\deng\deng\MD\image\project\计费规则.png)

有了rule和task就能做菜了。

DiscountCondition动态调价



### 代码

校验信息的时候放入 城市名称、服务类型、渠道名、用车等级。这4个就是计价规则的主键

Rule-计费规则主键类、基础计费、计费方法、远途服务费、夜间服务费
chargeRule，包含所有收费细节

通过设置进4个主键来查找规则是否存在（==如何判断时间==）
然后将查出来的chargeRule的id设置进Rule
继续将chargeRule的东西设置进Rule （rule中部分用的是BigDecimal）

根据chargeRule的ID取出chargeRuleDetailList
并判断取出的时间是否有问题

* 创建订单

  * 根据PassengerInfoId取PassengerInfo，所以需要先判空
  * 利用IdWorker工具类生成订单号
  * 订单设入乘客信息
  * 成功后将全局变量flag设为true
    因为外部只需要知道创建过程是否顺利，不需要它的返回值
  * 创建订单规则镜像

* 如果请求带id，则更新订单、计价信息

* 根据id去计价拉取价格

  * ```java
    public String get(String key) {
        return address.stream().filter(m -> m.containsKey(key)).findFirst().orElse(new HashMap<>(0)).get(key);
    }
    ```

* 生成计价规则，包含各种数据
  
  * 根据orderId拿到OrderRuleMirror，从而拿到Rule。(先从缓存拿，拿到后再设置进缓存)
  
* 准备过程
  * 先设置 分段计费 的参数
    * BigDecimal.valueOf
    * TimeMeter时间片计价器，其中有TimePriceUnit存放计价单位，通过计价单位和时间片来计算价格
    * 计价的时候
      速度换成double
      时间转换成LocalTime
      每公里价格转为每米价格，用自建工具类
      每分钟价格改为每秒
    * 设置结束时间的时候减一秒
      unit.setEnd(LocalTime.of(detail.getEndHour(),0,0).minusSeconds(1));

* 计算过程

  * 结果类TimeMeter.TimePriceResult
  * 先设置默认值
  * 通过LocalDateTime获得Duration对象
    Duration.between(start, end).getSeconds();

```xml

<select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="com.online.taxi.entity.ChargeRule">
    <!--
      WARNING - @mbggenerated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    select
    <include refid="Base_Column_List"/>
    from tbl_charge_rule
    where city_code =#{cityCode,jdbcType=VARCHAR} and service_type_id= #{serviceTypeId,jdbcType=INTEGER} and
    channel_id = #{channelId,jdbcType=INTEGER} and car_level_id = #{carLevelId,jdbcType=INTEGER}
    and active_status = 1 and is_unuse=0 and effective_time <![CDATA[<]]> NOW()
    order by effective_time desc
    limit 1
</select>
  
List<ChargeRule> selectByPrimaryKey(ChargeRule chargeRule);

<select id="selectByPrimaryKey" parameterType="com.dzp.internalcommon.entity.ChargeRule" resultMap="BaseResultMap">
    select 
    <include refid="Base_Column_List" />
    from tbl_charge_rule
    where city_code = #{cityCode,jdbcType=VARCHAR} and service_type_id =#{serviceTypeId,jdbcType=INTEGER} and
    channel_id = #{channelId,jdbcType=INTEGER} and car_level_id = #{carLevelId,jdbcType=INTEGER}
    and active_status = 1 and is_unuse=0 and effective_time <![CDATA[<]]> NOW()
    order by effective_time desc
    limit 1
  </select>
```



rule和task是关键

### 优化

![计价优化](E:\deng\deng\MD\image\project\计价优化.png)

3次DB操作可以合并，较少IO

高峰时创建订单后提交信息到MQ，异步计价，异步发送给客户





## 派单

task+队列 来达到轮询的目的

从大到小设计，隔离系统的变化点，
根据不同的规则执行不同的任务
推送的距离不同

### 业务流程

车和司机都是自己的，司机通过boss后台添加

司机到抢单界面Or成单界面

### 设计

隔离系统的变化点

首先拿到订单，抽取每个订单要走的相同的业务逻辑规则，也就是
distanceList是一个变化点，每个task有不同的TaskCondition

如果空闲司机的数量超过阈值，会让订单假派单成功，通过后台来进行派单

回家单：目的地和家在5公里以内

## 接单

极光做的，乘客和司机app上继承极光的sdk|
还可以用阿里的oss

用sse做。

派单时放入redis，key为 "业务"+driverId

> redis的发布订阅是阻塞的，影响性能

设备号用做黑名单



抢单需要分布式锁，抢单后才算生成正式的订单，因为这个时候订单才出现司机信息



## 订单状态

操作前状态+事件

取消时状态变为 91 92 。。。

状态只能前进或停止，不能后退

司机想取消订单需要打电话，人工处理

# 分布式事务



## 基础知识

为了保证多个服务的事务原子性，如支付系统和订单系统的事务

> 支付宝回调callback，支付系统和订单系统同步更新信息

刚性事务：ACID
柔性事务：db最终一致性

### XA

Transaction Manager	事务管理器TM
Resource Manager		资源管理器RM

由前者协调后者的事务提交，来做到控制事务一致性

![XA](E:\deng\deng\MD\image\project\XA.png)

### 2PC

两阶段提交

一阶段：TM向RM发起预提交请求，RM执行sql但不提交，并返回执行结果（任何一个失败都全部回滚）

二阶段：TM收到全部yes后让RM真正提交（任何一个失败都全部回滚）

一阶段执行sql不提交，如果这个时候出问题就回滚了，但不能阻止二阶段真正执行时出错



**打比方：**

​	两人吃饭100元，先每人交50到老板这，再下单

**缺陷**：

* TM单点故障使程序失效
* 二阶段时TM挂掉，不给RM发送提交的消息，会导致资源阻塞
  * 整个事务过程，资源是锁定的。
* 数据不一致
  * 2阶段commit后，一个执行失败，无法回滚

### 3PC

1. TM询问是否可以提交操作vote，等待参与节点响应
2. 参与节点响应并执行事务，将undo和redo写入日志，并反馈成功消息
3. 协调节点收到所有同义信息后向所有参与节点发送"正式commit"
4. 参与节点正式完成操作，并释放资源，反馈执行结果

**优化点**：

* 一阶段只询问，不执行sql，不会锁定资源，二阶段才开始锁定
* 2pc的TM有超时机制，RM没有（如果RM长时间没有回复消息，则终止事务）
* 3pc的TM/RM都有超时机制，降低灾难概率并不能避免（通过补偿机制弥补），
  三阶段如果RM没有收到TM的docommit命令，会自行提交，因为前两个阶段都没问题，即使TM挂了也不影响，同时自己的事务正锁定着资源，因此可以自行提交。

> 三阶段，如果RM1提交成功后RM2提交失败，只能自己补偿
>
> 定时任务、人工、脚本补偿
> 甚至需要写逆sql

**超时机制**

TM发现RM超时会命令RM回滚
RM发现TM超时会默认提交事务

## 消息队列+事件表实现



![消息队列+事件表](E:\deng\deng\MD\image\消息队列+事件表.png)

### 流程

1.1 支付宝callback，信息更新成功
1.2 新建支付成功事件(待确认)并插入事件表

2.1 新建支付成功时
2.2 将状态改为已发送
2.3 将消息发给消息队列

3.1 监听消息
3.2 收到消息插入事件表
3.3 ack

4.0 两表同步事务

> 消费消息时实现了幂等性，通过消息事件的id，主键约束，来保证消息重复消费的问题
> 因为事件表是共用的，如果消费者消费成功，但是ack时mq挂了，消费者会重复消费，但是此时它插库会出现主键冲突，因此只会有一条数据。

* 适用于中小公司，不适合处理大数据
* 建事件可以直接发给消息队列，但是并不能节省多少时间，因为还要等订单系统消费。同时出现bug时需要查两份bug，所以还是选了定时任务发送。
* 消息队列做持久化
* 事件表做成冷热数据
* 虽然前面复杂，但是后面再加上其他的服务，直接根据事件扔进消息队列同步就行
* 消费6次失败进死信队列

### 缺陷

我们公司是只起了一个定时任务，能cover住高峰期大概5000条数据。
但是如果起多个定时任务就需要分布式锁或分布式定时任务

不要为了极低概率的事件增加研发成本。

### 提供方代码

.\activemq start
反向生成、写xml select、写dao

#### activemq.xml

> 非持久化消息也用死信队列

```xml
<broker xmlns="http://activemq.apache.org/schema/core" brokerName="localhost" dataDirectory="${activemq.data}">

    <destinationPolicy>
        <policyMap>
          <policyEntries>
            <!--死信队列-->
			<policyEntry queue=">">  
                <deadLetterStrategy>  
                    <individualDeadLetterStrategy queuePrefix="DLQ."  
                      useQueueForQueueMessages="true" processNonPersistent="true" />  
                </deadLetterStrategy>  
            </policyEntry>
```

#### ProduceTask

```java
@Component
public class ProduceTask {

    @Autowired
    private TblOrderEventDao tblOrderEventDao;

    @Autowired
    private Queue queue;

    @Autowired
    JmsMessagingTemplate jmsMessagingTemplate;


    //Scheduled用法
    @Scheduled(cron="0/5 * * * * ?")
    @Transactional(rollbackFor = Exception.class)
    public void task() {
        System.out.println("定时任务开始");

        //取出所有OrderType为1的订单
        List<TblOrderEvent> tblOrderEvents = tblOrderEventDao.selectByOrderType("1");
        for (int i = 0; i <tblOrderEvents.size() ; i++) {

            TblOrderEvent tblOrderEvent = tblOrderEvents.get(i);
            // 根据orderId更改这条数据的orderType为2
            tblOrderEventDao.updateEvent(tblOrderEvent.getId());
            System.out.println("修改完成");
            //发送到消息队列
            jmsMessagingTemplate.convertAndSend(queue,JSONObject.fromObject(tblOrderEvent).toString());
        }
    }
}
```

### 消费方代码

#### 配置类	

```java
@Configuration
public class ActiveMQConfig {

    @Value("${spring.activemq.broker-url}")
    private String brokerUrl;

    /**
     * 连接工厂
     * @param redeliveryPolicy
     * @return
     */
    @Bean
    public ActiveMQConnectionFactory connectionFactory(RedeliveryPolicy redeliveryPolicy){
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("admin","admin",brokerUrl);
        activeMQConnectionFactory.setRedeliveryPolicy(redeliveryPolicy);
        return activeMQConnectionFactory;
    }

    /**
     * 重发配置
     * @return
     */
    @Bean
    public RedeliveryPolicy redeliveryPolicy(){
        RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
        return redeliveryPolicy;
    }

    /**
     * 设置消息队列 确认机制
     * @param activeMQConnectionFactory
     * @return
     */
    @Bean
    public JmsListenerContainerFactory jmsListenerContainerFactory(ActiveMQConnectionFactory activeMQConnectionFactory){
        DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();
        bean.setConnectionFactory(activeMQConnectionFactory);
        // 1: 自动确认，2： 客户端手动确认，3：自动批量确认，4 事务提交并确认。
        bean.setSessionAcknowledgeMode(2);
        return bean;
    }

}
```

#### TblOrderEventDao.xml

id需要自己加上，利用主键约束，保证消息不会被重复消费

```xml
  <insert id="insert" keyColumn="id" keyProperty="id" parameterType="com.example.servicepay.entity.TblOrderEvent" useGeneratedKeys="true">
    insert into tbl_order_event (id,order_type, `process`, content,
      create_time, update_time)
    values (#{id},#{orderType,jdbcType=VARCHAR}, #{process,jdbcType=VARCHAR}, #{content,jdbcType=VARCHAR},
      #{createTime,jdbcType=TIMESTAMP}, #{updateTime,jdbcType=TIMESTAMP})
  </insert>
```

#### TblOrderEventDao

要加@mapper，数据库的地址要改成service-pay

#### ConsumerQueue

```java 
@Component
public class ConsumerQueue {

    @Autowired
    private  TblOrderEventDao tblOrderEventDao;

    @JmsListener(destination = "ActiveMQQueue",containerFactory = "jmsListenerContainerFactory")
    public void receive(TextMessage textMessage, Session session) throws JMSException {
        try {
            String content = textMessage.getText();
            System.out.println("收到的消息："+content);

            TblOrderEvent tblOrderEvent = (TblOrderEvent) JSONObject.toBean(JSONObject.fromObject(content),TblOrderEvent.class);
            tblOrderEventDao.insert(tblOrderEvent);
            // 业务完成，确认消息 消费成功
            textMessage.acknowledge();
        }catch (Exception e){
            // 回滚消息
            e.printStackTrace();
//            e.getMessage(); // 用log打印。
            System.out.println("异常了");
            session.recover();
        }

    }

    /**
     * 补偿 处理（人工，脚本）。自己根据自己情况。
     * @param text
     */
    @JmsListener(destination = "DLQ.ActiveMQQueue")
    public void receive2(String text){
        System.out.println("死信队列:"+text);
    }
}
```

#### UpdateOrderTask

```java
@Component
public class UpdateOrderTask {

    @Autowired
    private MyOrderDao myOrderDao;

    @Autowired
    private TblOrderEventDao tblOrderEventDao;


    //Scheduled用法
    @Scheduled(cron="0/5 * * * * ?")
    @Transactional(rollbackFor = Exception.class)
    public void task() {
        System.out.println("定时任务开始");

        //取出所有OrderType为1的订单
        List<TblOrderEvent> tblOrderEvents = tblOrderEventDao.selectByOrderType("1");
        for (int i = 0; i <tblOrderEvents.size() ; i++) {

            TblOrderEvent tblOrderEvent = tblOrderEvents.get(i);
            //获取订单id
            Integer id = tblOrderEvent.getId();
            //更改订单状态
            myOrderDao.updateByOrderId(id);
            System.out.println("订单状态修改完成");
            // 根据orderId更改这条数据的orderType为2
            tblOrderEventDao.updateEvent(tblOrderEvent.getId());
            System.out.println("事件表修改完成");

        }
    }
}
```

## ==

2pc(协调者超时 回滚，占用连接，)

3pc (2pc的第一阶段 拆成了 2个阶段，协调者和参与者都超时，pre超时是回滚，do 超时是提交)。

tcc（2pc的第二阶段 拆成了2个阶段，不占用连接，性能高，但是麻烦）(简单业务可以tcc)。

lcn(lcn,tcc) (代码)

seata(at,tcc)（代码）

消息队列+本地事件表（代码）

最大努力通知

可靠消息服务

消息事务（代码）

## LCN

### 原理

https://www.codingapi.com/docs/txlcn-setting-distributed/

1. TM与TX、TC建立连接
2. 对TX发起事务请求，创建事务组，生成groupid
3. TX调用TC，在请求头中增加参数groupid
4. 后续服务添加到事务组，假关闭datasource连接
5. TM通知提交或回滚



![LCN原理](E:\deng\deng\MD\image\project\LCN原理.png)

![轮廓图](E:\deng\deng\MD\image\project\轮廓图.png)

> 每个服务都有个 TX client

**协调的本质：**代理了所有服务的datasource，保持了请求与db的连接，这样才可以通过TXmanager让所有服务提交或回滚

**补偿机制：**若没通知到服务，manager做记录存redis，manager会调用服务的补偿接口（TX client中）

### 实现

3个库：lcn-order、lcn-pay、TX-manager
1个缓存：redis
3个项目：lcn-order、lcn-pay、TX-manager

### TX-manager

#### **pom**

```xml
<!--tm-->
        <!-- tm  manager -->
        <dependency>
            <groupId>com.codingapi.txlcn</groupId>
            <artifactId>txlcn-tm</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>com.codingapi.txlcn</groupId>
            <artifactId>txlcn-tc</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>com.codingapi.txlcn</groupId>
            <artifactId>txlcn-txmsg-netty</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>
        <!--tm-->
```

#### yml

~~~yml
# TM事务管理器的服务端WEB访问端口。提供一个可视化的界面。端口自定义。
server.port=7970

# TM事务管理器，需要访问数据库，实现分布式事务状态记录。
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/tx-manager?characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root

# TM事务管理器，是依赖Redis使用分布式事务协调的。尤其是TCC和TXC两种事务模型。
spring.redis.host=127.0.0.1
spring.redis.port=6379
spring.redis.database=0

# 为spring应用起名。
spring.application.name=tx-lcn-transaction-manager

# TM事务管理器，提供的WEB管理平台的登录密码。无用户名。 默认是codingapi
tx-lcn.manager.admin-key=msb
# 日志。如果需要TM记录日志。则开启，赋值为true，并提供后续的配置。
tx-lcn.logger.enabled=true

# 为日志功能，提供数据库连接。和之前配置的分布式事务管理依赖使用的数据源不同。
tx-lcn.logger.driver-class-name=com.mysql.cj.jdbc.Driver
tx-lcn.logger.jdbc-url=jdbc:mysql://localhost:3306/tx-manager?characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
tx-lcn.logger.username=root
tx-lcn.logger.password=root
~~~

#### 启动类

@EnableTransactionManagerServer

### TC

#### pom

```xml
<!-- lcn -->
        <dependency>
            <groupId>com.codingapi.txlcn</groupId>
            <artifactId>txlcn-tc</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>com.codingapi.txlcn</groupId>
            <artifactId>txlcn-txmsg-netty</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>
```

#### yml

```yml
tx-lcn:
  client:
    manager-address: 127.0.0.1:8070  # tm地址
#集群的情况下不需要新加，TX会自己通知所有的client
```

#### 启动类

```java
@EnableDistributedTransaction
```

#### 业务类

@LcnTransaction

```java
@RestController
public class OrderController {

    @Autowired
    private TblOrderDao tblOrderDao;

    @Autowired
    private RestTemplate restTemplate;

    @PostMapping("/add-order")
    @Transactional(rollbackFor = Exception.class)
    @LcnTransaction
    public String add(@RequestBody TblOrder bean){

        JSONObject date = new JSONObject();
        date.put("payName",bean.getOrderName()+"pay");


        restTemplate.postForEntity("http://lcn-pay/add-pay",date,String.class);
        int i = 1/0;
        tblOrderDao.insert(bean);
        return "新增订单成功";
    }
}
```

## TCC

自带事务的不要用TCC，会增加复杂性

简单的业务可以用，3个sql操作以下

因为不占用连接，性能高

### 流程

TCC事务机制相对于传统事务机制（X/Open XA Two-Phase-Commit），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（**由业务系统提供的**）**业务逻辑**的调度来实现分布式事务。主要由三步操作，Try: 尝试执行业务、 Confirm:确认执行业务、 Cancel: 取消执行业务。

### 实现

增加confirm和cancel方法
db插入的时候返回id，（sql中加上`selectKey`标签）
通过map传到cancel中。

cancel中为逆sql

## Seata

### seata-AT

有全局锁，TCC模式没有，因为他会在cancel中逆操作实现回滚

### seata-TCC

try、confirm、cancel

tcc主要适用于无事务的db（redis、mongodb）

**tcc场景：（!（支持acid事务的关系型数据库） 和 xxx  ）。**



吞吐量低可以选择加入消息队列，
第一个服务TM处理后直接返回，后面异步处理



## 异同

LCN代理了datesource，执行过程中没有断开连接释放资源，因此可以自行回滚。

TCC则是自己写好Cancel，执行失败通过cancel手动回滚。



## 可靠消息最终一致性方案

![可靠消息服务](E:\deng\deng\MD\image\project\可靠消息服务.png)



1-1支付服务发送待确认消息给自己开发的可靠消息服务
1-2若成功则执行业务逻辑操作DB，
1-3操作DB成功/失败 则 发送相应消息

1-1-1保存消息为待确认状态，
2-1 根据1-3的消息来更改信息状态
2-2发送到MQ



由自己开发的可靠消息服务来管理消息，高大上一些叫可靠消息中台
相当于事件表的综合，就不是由自己来创建相应的事件表
支付系统提供回调接口，来重新发送消息

适用于时效性不高的服务
==优势==是吞吐量大，响应快，可以提高并发量。因为请求过来后，只需要发送待确认消息，操作DB，向中台发送消息，就返回了。后续处理不管
相当于把整条调用链路变成调用单体的单个功能

比如你下订单以后，后面可能涉及到需要操作，如加积分、走物流、给待确认消息，操作DB，向中台发送消息，就返回了。后续处理不管
==相当于把整条调用链路变成调用单体的单个功能==

![加中间状态提高并发](E:\deng\deng\MD\image\project\加中间状态提高并发.png)



## 最大努力通知

**应用场景：**应用在第三方系统，第三方的开放平台用的

如果商户反馈给支付宝的不是success字符，支付宝服务器会不断重发通知，直到24小时22分钟，一般情况下25小时内通知8次

还提供了接口让你主动回调查看状态



## 事务消息

这个跳过自己开发的可靠消息服务(中台)

使用rocketMQ的事务消息机制
provider发送Half Message
executeLocalTransaction中写入要执行的事务，成功则commit，失败标记后broker会调用checkLocalTransaction

发送Half Message到rocketMQ（看事务消息MD）此时是无法被消费的
确认后执行本地事务，再向rocketmq发送确认或者是回滚的消息。
如果这一步出现问题也没有关西
因为broker会开启定时任务，向发送者确认事务状态。（通过回查事务表【自建】）



**细节：**

回查事务ID来确认事务状态

![事务消息](E:\deng\deng\MD\image\project\事务消息.png)



# 分布式锁

客户端某个服务，而这个服务是个集群

### 场景

一个订单，多个司机抢单。
多个抢单请求打到service-order，只能让一个司机收到成功的消息。此时Jvm的锁是锁不住的
核心思想是找出一个能够跨服务的东西当做锁



redis分布式锁中

* 业务finally中会释放锁，同时锁自身也有过期时间。
  那么就可能出现业务执行超过了锁自身过期时间，再执行finally释放锁，然后释放了其它同名的锁



### mysql锁

ThreadLocal中放入TblOrderLock作为锁对象

加锁就是把TblOrderLock插库，插库失败就说明拿不到锁
unlock解锁就是删库，再删掉ThreadLocal中的TblOrderLock
设置个触发器，向redis的过期时间，超时自动解锁



**特点：**
小项目可以用，高并发对数据库压力较大

```java
@Service
@Data
public class MysqlLock implements Lock {

   @Autowired
   private TblOrderLockDao mapper;
   
   private ThreadLocal<TblOrderLock> orderLockThreadLocal ;

   //阻塞式加锁
   @Override
   public void lock() {
      // 1、尝试加锁
      if(tryLock()) {
         System.out.println("尝试加锁");
         return;
      }
      // 2.休眠
      try {
         Thread.sleep(10);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
      // 3.递归再次调用
      lock();
   }
   
   /**
    *     非阻塞式加锁，成功，就成功，失败就失败。直接返回
    */
   @Override
   public boolean tryLock() {
      try {
         TblOrderLock tblOrderLock = orderLockThreadLocal.get();
         mapper.insertSelective(tblOrderLock);
         System.out.println("加锁对象："+orderLockThreadLocal.get());
         return true;
      }catch (Exception e) {
         return false;
      }
      
      
   }
   
   @Override
   public void unlock() {
      mapper.deleteByPrimaryKey(orderLockThreadLocal.get().getOrderId());
      System.out.println("解锁对象："+orderLockThreadLocal.get());
      orderLockThreadLocal.remove();
   }
```



### 面试用

```java
@Service("grabRedisLockService")
public class GrabRedisLockServiceImpl implements GrabService {

   @Autowired
   StringRedisTemplate stringRedisTemplate;
   
   @Autowired
   OrderService orderService;
   
    @Override
    public String grabOrder(int orderId , int driverId){
        //生成key
       String lock = "order_"+(orderId+"");
       /*
        *  情况一，如果锁没执行到释放，比如业务逻辑执行一半，运维重启服务，或 服务器挂了，没走 finally，怎么办？
        *  加超时时间
        *  setnx
        */
//     boolean lockStatus = stringRedisTemplate.opsForValue().setIfAbsent(lock.intern(), driverId+"");
//     if(!lockStatus) {
//        return null;
//     }
       
       /*
        *  情况二：加超时时间,会有加不上的情况，运维重启
        */
//     boolean lockStatus = stringRedisTemplate.opsForValue().setIfAbsent(lock.intern(), driverId+"");
//     stringRedisTemplate.expire(lock.intern(), 30L, TimeUnit.SECONDS);
//     if(!lockStatus) {
//        return null;
//     }
       
       /*
        * 情况三：超时时间应该一次加，不应该分2行代码，
        * 
        */
       boolean lockStatus = stringRedisTemplate.opsForValue().setIfAbsent(lock.intern(), driverId+"", 30L, TimeUnit.SECONDS);
       // 开个子线程，原来时间N，每个n/3，去续上n
       
       if(!lockStatus) {
          return null;
       }
       
       try {
         System.out.println("司机:"+driverId+" 执行抢单逻辑");
         
            boolean b = orderService.grab(orderId, driverId);
            if(b) {
               System.out.println("司机:"+driverId+" 抢单成功");
            }else {
               System.out.println("司机:"+driverId+" 抢单失败");
            }
            
        } finally {
           /**
            * 这种释放锁有，可能释放了别人的锁。
            */
//         stringRedisTemplate.delete(lock.intern());
           
           /**
            * 下面代码避免释放别人的锁
            */
           if((driverId+"").equals(stringRedisTemplate.opsForValue().get(lock.intern()))) {
            stringRedisTemplate.delete(lock.intern());
         }
        }
        return null;
    }
}
```

# 面试级业务

## 登录

### 代码要点

* 发送验证码请求打过来

  * ShortMsgRequest作为发验证码的封装类，对号码加了注解正则
  * @Validated校验异常

* 校验手机号通过，通知发验证码

  * 结果code封装进VerifyCodeResponse
    因为不止用来装验证码

  * ```java
    ResponseResult result = restTemplate.exchange(url, HttpMethod.GET,new HttpEntity<Object>(null,null),ResponseResult.class).getBody();
    ```

  * 生成验证码不要用(Math.random()+"").subString(2,8)
    字符串操作效率低

* 校验发送成功，

  * else{return ResponseResult.fail("发送短信失败");}

* 

service-sms

短信的模板是直接放在内存里的，因为短信模板80B，最多占用不到1M内存，不用redis



## 支付

### 场景

弹出支付页面，用户点击付款，调起/pretreatment准备参数，（先充值，再消费）

### 细节

支付宝端会定时回调我们的callback接口，即使一次失败也没关系，直到我方返回success，对方才停止





# 实操

## 功能列表

### 用户登录

 ![登录服务](E:\deng\deng\MD\online-taxi\登录服务.png)

#### 大体流程

创建各项目，测试，配置yml,

api-passenger和service-verification-code都需要的参数抽象到common中

生成验证码，用户输入后点确定，校验验证码，

#### application.yml

~~~yml
server:
	port: 8081
eureka:
	client: 
		enabled: false
spring:
	application:
		name: service
~~~

#### 接口设计

把service整得更通用一些，因为即使同一个手机号有可能有多种身份

==sms封装的参数在这里==

![接口设计](E:\deng\deng\MD\online-taxi\接口设计.png)



### 消息队列+时间表做分布式事务

service-order
service-pay

注意启动类注解

## 开发技巧

* controller接入RequestBody，然后提取出其中的有用信息（如phoneNumber）,传入service中执行业务（service只需要number就行了）
* 外部请求先打到网关，需要鉴权，网关再调用业务的时候就不用反复鉴权
* **注释引起编码错误**

* 本地db操作先行，调用其它系统在后，方便回滚（可控性排序）

## 代码技巧

### 类型转换

#### JSON转对象

```java
ObjectMapper objectMapper = new ObjectMapper();
rule = objectMapper.readValue(ruleJson, Rule.class);
```

#### Object转对象

```java
public static <T> T parse(@Nullable ResponseResult result, Class<T> clazz) throws Exception {
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(mapper.writeValueAsString(result != null ? result.getData() : null), clazz);
}
```



#### 实体对象转成Map

```java
/**
 * 实体对象转成Map
 *
 * @param obj 实体对象
 * @return
 */
public static Map<String, Object> object2Map(Object obj) {
    Map<String, Object> map = new HashMap<>(281);
    if (obj == null) {
        return map;
    }
    Class clazz = obj.getClass();
    Field[] fields = clazz.getDeclaredFields();
    try {
        for (Field field : fields) {
            field.setAccessible(true);
            map.put(field.getName(), field.get(obj));
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return map;
}
```

### BigDecimal

BigDecimal计算价格，用来对超过16位有效位的数进行精确的运算， BigDecimal所创建的是
对象，故我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。

### Json使用

```java
if (responseResult.getCode() == CommonStatusEnum.SUCCESS.getCode()){
    //获取json格式的验证码
    JSONObject data = JSONObject.fromObject(responseResult.getData().toString());
    //==JSON用法-验证码转为VerifyCodeResponse
    verifyCodeResponse = (VerifyCodeResponse)JSONObject.toBean(data,VerifyCodeResponse.class);
}else {
    return ResponseResult.fail("获取验证码失败");
}
```

### Redis

存两分钟

```java
//set和过期时间放一起，否则不是原子操作，服务器中间挂了，就只存不过期了
BoundValueOperations<String, String> codeRedis = redisTemplate.boundValueOps(key);
codeRedis.set(code,2,TimeUnit.MICROSECONDS);
```



## 开发中出现的问题

* 用户的时间跟服务器的时间不一样，需要同步时间
* 有旅游团刷单，不给钱
* 假派单成功
  * 设置空闲司机数量，如果超过这个数量，给用户假派单成功，转人工派单。
    防止用户通过规则没有匹配上车辆
* 派单中的规则是boss端写进数据库的，应用规则时到数据库里取，如多少公里内派单，前后时间间隔等等。

### enum类

```java
public class RedisKeyPrefixConstant {
   /**
    * 乘客登录验证码 key前缀
    */
   public static final String PASSENGER_LOGIN_CODE_KEY_PRE = "passenger_login_code_";

   public static final String PASSENGER_LOGIN_TOKEN_APP_KEY_PRE = "passenger_login_token_app_";

   public static final String PASSENGER_LOGIN_TOKEN_WEIXIN_KEY_PRE = "passenger_login_token_weixin_";

   /**
    * 司机登录验证码 key前缀
    */
   public static final String DRIVER_LOGIN_CODE_KEY_PRE = "driver_login_code_";


}
```

### 判断String为空

```java
StringUtils.isNotBlank()
```

## 架构完成后，需要练习的点

* 存入redis
* 收藏常用路线，存库
* 地图围栏服务（map-service）
* 

# 开发实用技巧

## redis

存redis

```java
    /**
     * 从缓存中设置计价对象
     *
     * @param orderId    订单ID
     * @param priceMeter 计价对象
     * @param timeout    过期时间
     * @param unit       过期时间单位
     */
public void set(Integer orderId, PriceMeter priceMeter, long timeout, TimeUnit unit) {
    String key = generateKey(orderId);
    log.info("设置缓存orderId={}, PriceMeterInRedis={}", orderId, key);
    try {
        //将类转换为json字符串
        redisTemplate.opsForValue().set(key, mapper.writeValueAsString(priceMeter), timeout, unit);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
    }
}
/**
     * 生成redis的key
     *
     * @param orderId 订单ID
     * @return redis的key
     */
    private String generateKey(Integer orderId) {
        return String.format("%s:%s:%s", OrderRuleNames.PREFIX, OrderRuleNames.PRICE, orderId);
    }
```

## 注解

#### @Qualifier

在相应的service实现类上加别名  @Service("grabRedisRedissonRedLockLockService")

```java
// 红锁
@Qualifier("grabRedisRedissonRedLockLockService")
private GrabService grabService;
```



## 类、Json格式转换

### Json转对象

```java
ObjectMapper objectMapper = new ObjectMapper();
rule = objectMapper.readValue(ruleJson, Rule.class);
```

### 实体对象转为Map

~~~java 
    public static Map<String, Object> object2Map(Object obj) {
        Map<String, Object> map = new HashMap<>(281);
        if (obj == null) {
            return map;
        }
        Class clazz = obj.getClass();
        Field[] fields = clazz.getDeclaredFields();
        try {
            for (Field field : fields) {
                field.setAccessible(true);
                map.put(field.getName(), field.get(obj));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return map;
    }
~~~

### Object转String

```java 
//rule转为string存数据库
new ObjectMapper().writeValueAsString(rule)
```

### 字符串转实体类

```java
private static <T> T parse(String jsonStr, Class<T> clazz) {
    ObjectMapper om = new ObjectMapper();
    T readValue = null;
    try {
        readValue = om.readValue(jsonStr, clazz);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return readValue;
}
```

### 提取ResponseResult中的data为指定类

```java
//获取json格式的验证码(原本是VerifyCodeResponse格式的)
JSONObject data = JSONObject.fromObject(responseResult.getData().toString());
//==JSON用法-验证码转为VerifyCodeResponse
verifyCodeResponse = (VerifyCodeResponse)JSONObject.toBean(data,VerifyCodeResponse.class);
```

### ResponseResult解析为指定的类





## 单位转换工具类

```java
/**
 * 单位转换工具类
 *
 * @date 2018/08/15
 */
public class UnitConverter {

    /**
     * 将Date转换为LocalDateTime
     *
     * @param date Date
     * @return LocalDateTime
     */
    public static LocalDateTime dateToLocalDateTime(Date date) {
        return LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
    }

    /**
     * 将Date转换为LocalDate
     *
     * @param date Date
     * @return LocalDate
     */
    public static LocalDate dateToLocalDate(Date date) {
        return dateToLocalDateTime(date).toLocalDate();
    }

    /**
     * 将Date转换为LocalTime
     *
     * @param date Date
     * @return LocalTime
     */
    public static LocalTime dateToLocalTime(Date date) {
        return dateToLocalDateTime(date).toLocalTime();
    }

    /**
     * 将每公里价格转换为每米价格
     *
     * @param price 每公里价格
     * @return 每米价格
     */
    public static BigDecimal kiloToMeterPrice(BigDecimal price) {
        return price.divide(new BigDecimal("1000"), 5, RoundingMode.DOWN);
    }

    /**
     * 将每分钟价格转换为每秒价格
     *
     * @param price 每分钟价格
     * @return 每秒价格
     */
    public static BigDecimal minuteToSecondPrice(BigDecimal price) {
        return price.divide(new BigDecimal("60"), 5, RoundingMode.DOWN);
    }

    /**
     * 秒数转为分钟数
     *
     * @param seconds 秒数
     * @return 分钟数
     */
    public static double secondToMinute(Double seconds) {
        return BigDecimal.valueOf(Optional.ofNullable(seconds).orElse(0D)).divide(BigDecimal.valueOf(60), 2, RoundingMode.HALF_DOWN).doubleValue();
    }

    /**
     * 将米数转为公里数
     *
     * @param meters 米数
     * @return 公里数
     */
    public static double meterToKilo(Double meters) {
        return BigDecimal.valueOf(Optional.ofNullable(meters).orElse(0D)).divide(BigDecimal.valueOf(1000), 2, RoundingMode.HALF_DOWN).doubleValue();
    }

}
```

## 判空

```java
if (!StringUtils.isEmpty(orderDtoRequest.getPassengerInfoId().toString()))
```

## 对象比较



```java
//可以比较null
if (!ObjectUtils.nullSafeEquals(chargeRule.getBaseKilo(), BigDecimal.ZERO.doubleValue()) 
```

## sql

需要带上，and isDelete = 0，代表没被删除的条目

```xml
<select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
  select 
  <include refid="Base_Column_List" />
  from tbl_charge_rule_detail
  where rule_id = #{ruleId,jdbcType=INTEGER} and isDelete = 0
</select>
```

## 日志

```java
log.info("orderId={}, RuleJson={}", orderId, ruleJson);
```

```java
log.error("orderId={}, 解析RuleJson错误:", orderId, e);
```

## **使用Optional优化代码**

```java
public` `static` `String getUserNameByOptional(User user) {``  ``Optional<String> userName = Optional.ofNullable(user).map(User::getName);``  ``return` `userName.orElse(``null``);``}
```

## 通用枚举类

 return 字符串格式的code值，其它的枚举类都实现这个接口

```javascript
public interface CodeEnum {

    /**
     * 返回枚举体的code值
     *
     * @return code值
     */
    int getCode();

    /**
     * 返回枚举体的code值
     *
     * @return 字符串格式的code值
     */
    default String getCodeAsString() {
        return "" + getCode();
    }
}
```

## 通用

```java
capital = capital==null?0d:capital;
giveFee = giveFee==null?0d:giveFee;
```

~~~java
//按指定格式输出String 
String.format()

~~~

## BigDecimal

用于高精度计算

加法  a.add(b) 

减法 a.subtract(b) 

乘法 a.multiply(b) 

除法 a.divide(b)

## 时间类

Duration

LocalDateTime

LocalDate

## mybatyis

### 便捷改mybatis

看灰度发布-网关灰度
cloud-zuul里的例子

### 更新数据

先new对象，再根据对象属性update。

## copy代码出错

xml的namespace没改



# 开发业务思考

### 预估价格服务

根据返回的起点终点距离需要判断情况
如计算出的距离过短或过长，需要相应提示

## 枚举类

通用的枚举类放在二方库，微服务单独用的枚举自己管理
比如判定距离是否过长过短只要放在判断距离的order-service就行了，不用放二方库。

#### 订单状态集合

距离判定数据设定

## 日志log

接入请求类后log

### 调用其它服务返回的值log

### catch中异常

```java
try {
            String url = "http://service-map/distance";
            ResponseResult responseResult = (ResponseResult)restTemplate.postForEntity(url,distanceRequest,ResponseResult.class).getBody();

            route = RestTemplateHepler.parse(responseResult,Route.class);
//log
            log.info("测量距离返回：{}",route);
            if (route.getDistance()==null || route.getDuration()==null){
                return ResponseResult.fail(BusinessInterfaceStatus.FAIL.getCode(), "测量距离失败");
            }
            if (route.getDistance() <= 0){
                return ResponseResult.fail(Distance.TOO_CLOSE.getCode(),Distance.TOO_CLOSE.getValue());
            }
            if (route.getDistance() > Distance.DISTANCE.getCode()){
                return ResponseResult.fail(Distance.TOO_FAR_AWAY.getCode(),Distance.TOO_FAR_AWAY.getValue());
            }
            if (route.getDuration() > Distance.DURATION.getCode()){
                return ResponseResult.fail(Distance.TOO_FAR_AWAY.getCode(),Distance.DURATION.getValue());
            }
        } catch (Exception e) {
//log 
            log.error("调用接口Distance错误",e);
            e.printStackTrace();
            return ResponseResult.fail(BusinessInterfaceStatus.FAIL.getCode(),"测量距离失败");
        }
        return ResponseResult.success(route);
```

# 需要问人的点

计价服务中OrderRuleMirrorDao，为什么要这么一个镜像。

entity是反向生成的

requestTask干什么用，并没有请求打进来，怎么用。

TCC测试中mapper.xml中的insert语句中还有selectKey

