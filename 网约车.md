司乘同显
高德的服务，比较贵

| 乘客           | 司机         |
| -------------- | ------------ |
| 呼叫用车       | 出车         |
| 等待司机接单   | 接单         |
|                | 到达约定地点 |
| 司乘同显       | 发起收款     |
| 跳转支付宝付款 |              |

## 项目概述

**1、逸品专车项目**
**项目描述**：
此项目是一款网约车软件，主要功能包括：

乘客端：登录注册，下单，支付，评价，推护个人信息等。

司机端：台录。出车收车，接乘客到订单完成，发起收款等。

车载大屏：同步司机和乘客信息，广告投放，第三方应用投放。

车机端：类似司机端功能，区别是在车机上操作，

项目中职责：业务需求评审，协议制定，服务端板架搭建，架构设计，技术选型，核心功能实现。

1、独自完成注册中心优化，节省了服务的上下找时间，降低了无效服务的调用率，提高了接口调用的成功率。

2、review代码时，提升了10倍效率。

**功能：**
1、地图模块：主要是接入第方地图实现，4车辆同步，辆调度，里程查询，轨透点查询，路径规划，距离计算，围栏限定等。
2、消息模块：轮寻消息，推送，短信等。
3、派单引象：实时单派单，预约单派单，抢单等。
4、订单系统：订单创建，修改，状态变史等。
5、计价系统：基础计价，动态调价，分时段计价。
6、支付系统：接入微信支付，支付宝支付。余额充值，资会漆结，订单退款等。
7、账号系统；乘客注册求，乘客信息推护。司机求入，司机录，司机信息推护等。



## 服务拆分

### 业务层

| 模块     | 项目名           | 描述 |
| -------- | ---------------- | ---- |
| 乘客端   | api-passenger    |      |
| 司机端   | api-driver       |      |
| 司机听单 | api-listen-order |      |

### 能力层

| 模块         | 项目名                    |
| ------------ | ------------------------- |
| app升级      | service-app-update        |
| 订单         | service-order             |
| 派单         | service-order-dispatch    |
| 乘客用户管理 | service-passenger-user    |
| 短信         | service-sms               |
| 计价         | service-valuation         |
| 验证码       | service-verification-code |
| 钱包         | service-wallet            |
| 支付         | service-payment           |

### 基础common

所有服务都引用的二方库

| 模块                  | 项目名          |
| --------------------- | --------------- |
| 通用,工具类,异常,校验 | internal-common |



### spring cloud基础

| 模块         | 项目名                  |
| ------------ | ----------------------- |
| 注册中心     | cloud-eureka            |
| 配置中心     | cloud-config-server     |
| 网关         | cloud-zuul              |
| 熔断监控(ui) | cloud-hystrix-dashboard |
| 健康检查     | cloud-admin             |
| 链路追踪     | cloud-zipkin-ui         |







## 架构

架构，模式，拆分，隔离，目标：**隔离系统的变化点**。

### 具体原则：

高内聚，低糊合。
高度自治：开发，测试，构建，部署，运行，发布。（无状态）
以业务为中心。
弹性设计。（容错，隔离，降级）。
自动化。持续集成，持续交付。

粒度把控：没有标准。任何一个服务，不要因为自己的开发和维护，影响其他服务。

api组，service组

业务层，能力层



### AKF



### 乘客端

1.发送验证码。
三挡验证。技术人员防止恶意发短信。
2.登录/注册。
3.查看开通区域
高德围栏
4.预估价格。
5.下单
6.（司机流程）
7.支付
8.评价。

### 司机端

1.发送验证码
2.登录，注册
3.查看，改变司机状态。
4.司机抢单（分布式锁）
5.订单状态变更。
6.发起收款





![架构图](E:\deng\deng\MD\image\didi\架构图.png)



### 包装

包装：云云。商务都来公司，跟我们技术做个交流，我们也了解他们怎么。技术情况，和我们业务结合是否匹配，开发是否易用，稳定，。。XXX。



qps:2000

### 接口设计



重在：资源。
协议：https.ios只能用https（？）.
域名：/restapi.yuming.com/
版本：1路径：/xxoo/xxoo/（名词）
动作：
	post：新建
	put：修改（修改后的全量数据） 
	patch：修改（改哪个，传哪个）
	delete：删除
	get：查询





### 安全

三级等保

**CIA**：保密性，完整性，可用性

私密数据脱敏。

**数据层面**：sql注入

jsoup框架过滤接口

#### xss,csrf

spring-htmlUtils



#### 数据权限控制



## 微服务



公司maven私服

两个服务会调用同一个Bean，那就把它抽象到common层，避免重复创建



### 异常

dao层：不打日志，catch

service：打日志，详细信息。时间，参数，

controller：异常包装成状态码。T



## 搭建

### 配置项目

* 新建maven，删除pom外的其它

* 搭服务端
  
  * new module->spring init(cloud-eureka)
    
  * 勾选developer tools下的Lombok
  
  * Spring Cloud Discover下Eureka Server
  
  * 添加@EnableEurekaServer注解
  
  * ```yml
    #server:
    #port: 7900
    spring:
      application:
        name: EurekaServer
    eureka:
      instance:
    #    prefer-ip-address: true
    #    ip-address: 127.0.0.1
      client:
        register-with-eureka: true
        fetch-registry: true
        service-url:
          defaultZone: http://eureka-7900:7900/eureka/,http://eureka-7901:7901/eureka/,http://eureka-7902:7902/eureka/
      server:
        #自我保护
        enable-self-preservation: false
        #自我保护阈值
        renewal-percent-threshold: 0.85
        #快速下线（剔除服务时间间隔）
        eviction-interval-timer-in-ms: 1000
        #多级缓存
        use-read-only-response-cache: false
        #readWrite和readOnly同步时间间隔
        #减少同步时间也能加快发现服务的速度
        response-cache-update-interval-ms: 1000
    
    
    
    ---
    spring:
      profiles: 7901
    server:
      port: 7901
    eureka:
      instance:
        hostname: eureka-7901
    
    ---
    spring:
      profiles: 7902
    server:
      port: 7902
    eureka:
      instance:
        hostname: eureka-7902
    
    ---
    spring:
      profiles: 7900
    server:
      port: 7900
    eureka:
      instance:
        hostname: eureka-7900
    ```
  
* api-passenger(provider-passenger)

  * Lombok、Eureka Discovery、web
  * 启动主程序
  
* internal-common二方库

  * Lombok

* <version>0.0.1-SNAPSHOT</version>

  * 实际上线的话要去掉SNAPSHOT，否则会更新新提交的东西



### 启动过程

#### 总览

* 数据同步

  * 启动拉取服务列表

    再启动集群同步



#### 细节

1.从peer拉取注册表（peer就是配置中的Default）

2.启动定时剔除任务

3.自我保护

4.续约

5.下线

6.集群间同步

自动装配EurekaServerAutoConfiguration

@EnableEurekaServer注解的作用就是new Marker() 空类

EurekaServer启动会判断是否存在Marker()类，再开启EurekaServer



~~~java
//因为续约比较频繁，这么设计可以加快服务速度（不然还得调用实例中的time属性）
class 租约{
	long 到期time;
    long 心跳time;
    T 服务实例holder
}
~~~









### CAP

不满足C	—— 一致性

因为服务开启的时候才拉取一次，



1.三级要存。
2.从其他peer拉取注册表。peer.int registryCount=this.registry，syncUp）.没有满足C的地方。
3.P：网络不好的情况下，还是可以拉取到注册表进行调用的。

### Eureka优化

#### server优化

* 自我保护
  * 1.阈值
    2.开关
  * 比如系数是80，也就是保护80%的节点，20个挂了，1个抖动，不会提出这个
  * 服务数量少时，服务挂了基本就是挂了，不开自我保护
    服务数量多时，服务挂了可能是网络波动，开自我保护

* 快速下线

  * Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行，使用ScheduleExecutorService则没有这个问题
  * 减少服务上下线的延时

* 三级缓存（register，readWriteCacheMap，readOnlyCacheMap）

  * 新服务注册后会让readWriteCacheMap失效

  * 后两者的数据是30s同步一次的，为了高可用

  * ```yml
    #会直接从readWriteCacheMap拿数据，并发压力不高时设置
    use-read-only-response-cache: false
    #减少同步时间也能加快发现服务的速度
    response-cache-update-interval-ms: 1000
    ```
    

* 服务更新： 先停止，再发送下线请求，因为先下线可能会续约

~~~yml
server:	
	#自我保护
    enable-self-preservation: false
    #自我保护阈值
    renewal-percent-threshold: 0.85
    #快速下线（剔除服务时间间隔）
    eviction-interval-timer-in-ms: 1000
    #多级缓存
    use-read-only-response-cache: false
    #readWrite和readOnly同步时间间隔
    #减少同步时间也能加快发现服务的速度
    response-cache-update-interval-ms: 1000
~~~



#### client优化

注册，拉取，下线，3个定时任务

* heartbeatExecutor	心跳定时任务
  * cacheRefreshTask
  * heartbeatTask
  * statusChangeListener
    * 如果自身服务有变，重新注册



* 实际工作中，要把后面的url随机打乱
  * 因为默认是访问第一个，如果都配置一样的，会使得第一个压力过大
  * eureka会相互注册，所以会共享
    因此新来服务只注册第一个，就会被全部共享

```yml
server:
  port: 8080
eureka:
  #与server交互
  client:
    service-url:
      defaultZone: http://localhost:7900/eureka/
     
    #服务表拉取间隔时间
    registry-fetch-interval-seconds: 30
    #使与注册中心无关，禁用eureka-client
    enabled: false
  instance:
    #续约时间间隔
    lease-renewal-interval-in-seconds: 30

spring:
  application:
    name: api-passenger
logging:
  level: debug
```



### 服务测算

20个服务每个服务部署5个，eureka client：100个。
1分钟200。
心跳，向server发送我们活着，一天几十万次（对server来说）

集群并没有扩大承受能力，是为了高可用



### region

减少网络延迟



## 面试问题

先停服后下线，

因为先下线可能会续约

* 注释引起编码错误



* 发送短信的服务
  * 腾讯短信通、案例短信、华信

* review代码时，提升了10倍效率。
  * 生成验证码的速度

# 实操



## 用户登录



 ![登录服务](E:\deng\deng\MD\online-taxi\登录服务.png)

### 大体流程

创建各项目，测试，配置yml,

api-passenger和service-verification-code都需要的参数抽象到common中

生成验证码，用户输入后点确定，校验验证码，

### application.yml

~~~yml
server:
	port: 8081
eureka:
	client: 
		enabled: false
spring:
	application:
		name: service
~~~

### 接口设计

把service整得更通用一些，因为即使同一个手机号有可能有多种身份

![接口设计](E:\deng\deng\MD\online-taxi\接口设计.png)





## 需要源码的

ResponseResult