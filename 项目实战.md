## CompletableFuture

supplyAsync用于有返回值的任务，

runAsync则用于没有返回值的任务

#### 计算完成后续-complete



#### 计算完成后续-handle



### 应用

使用@Async注解修饰方法

默认会由spring创建线程池
默认核心线程8，最大线程数是MAX_VALUE，可能会无限制创建线程
通过自定义配置

~~~java
spring:
  task:
    execution:
      pool:
        max-size: 6
        core-size: 3
        keep-alive: 3s
        queue-capacity: 1000
      thread-name-prefix: name
~~~



## 分布式锁

### 抢单

redis.setnx

单例模式（构造方法私有、static创建对象、提供public静态方法提供实例

抢单时，lockRedis.setIfAbsent()
锁住之后修改订单状态，最后删除锁。

如果业务代码超过了15秒的过期时间，另一个司机就会拿到锁执行代码，最后会显示两个司机都抢到了订单，出现异常。

### Redisson

Redisson采用了基于NIO的Netty框架

Rlcok 分布式可重入锁

~~~java
        RLock rLock = redissonClient.getLock("orderId");
        rLock.lock();
~~~

看门狗默认续期30s

### 分布式ID

推特采用synchronized 锁住nextId()方法。

因为我们并发量并没有这么大，所以采用CAS的方式，方法本身没有加锁。在时间戳和最后时间戳不同时，将sequence设置为0，然后在时间戳后加上







## 秒杀

数据尽量少，页面简单

秒杀的场次时间，和秒杀的产品在后台配置
开启定时任务，每天凌晨3点查找后三天的秒杀信息放置到缓存



![image-20220704223554184](项目实战.assets/image-20220704223554184.png)

### 定时任务缓存进redis

类上@EnableScheduling

1. 方法上 @Scheduled(cron = "* * * * * ?")
2. spring默认的线程池里核心线程只有1个，没完成默认是阻塞的。可以选择自己放入线程池执行。
3.  开启异步任务，在方法上@EnableAsync

* 每晚3点上架最近三天需要秒杀的商品
  * LocalTime.Min
  * LocalDateTime.of() 组合日期和时间
  * 开始时间_结束时间的long值为key，value为sessionId_skuId
    redisTemplate.opsForList().leftPushAll(k,v)
  * 再存一组活动id为key，保险内容json为value
    用Hash来存

* 设置随机码，防止脚本抢，在活动开始的时候才暴露这个随机码

* 设置秒杀商品的分布式信号量
  通过

  ~~~java
  RSemaphore semaphore = redissonClient.getSemaphore("seckill:stock"+"随机码")
  semaphore.trySetPermits("库存")
  ~~~

* 处理秒杀上架的幂等性

  * redisTemplate.hasKey()

### 返回当前时间的秒杀商品

​	



## Eureka生产优化

### 自动装配

starter包下都有个spring.factories，标记自动装配的类
EurekaServerAutoConfiguration
上面有@ConditionalOnBean({Marker.class})需要这个类，
然后启动类上加@EnableEurekaServer就只是注入了一个空Marker类

### 启动流程

加入了剔除任务，server端定期将没有心跳的服务剔除
设置进剔除任务的时间间隔毫秒数（默认60s，改成1秒）

* 从其它peer拉取注册表，那么拉取操作后的一段时间，再有新的节点是暂时没有同步的。

  需要通过后面的“集群同步” 再更新

添加事件(服务注册、服务开始、服务下线)到context

### 自我保护

服务少不开自我保护，因为挂了大概率是真挂了

服务多开自我保护，因为网络抖动的概率比较大

默认的剔除阈值为 0.85

### 快速下线

从源码进去看到它剔除不可用服务是通过Timer.schedule()来剔除的，这其实有个问题的，多线程并行处理任务时，Timer运行多个TimeTask，只要其中一个没有捕获抛出的异常，其它任务便会自动终止运行，换成ScheduleExecutorService比较好（可执行延迟任务，循环任务）

,设置进了2个参数，其中剔除的时间默认是60s，那么这段时间内就可能拉取到不可用的复位

监控下线事件，并发邮件通知。

### 优化多级缓存

register、readWriteCacheMap、readOnlyCacheMap

use-read-only-response-cache 设置为false

都说eureka实现了AP, 没有实现C

服务注册进入eurekaServer的addInstance方法。
更新register注册表（ConcurrentHashMap）
Map<服务名，map<实例id, 实例信息>>

新注册会让缓存readWriteCacheMap失效，但readWrite和readOnly之间的数据是30s同步一次的，一致性比较低，因此我选择舍弃一层缓存，换取强一些的一致性。

当取注册表信息的时候，才去从register读取。

### 服务注册

addInstance
通过http的方式交互，其实eureka这里代码写得也不是太好
一堆的if else进行空值校验，通过validate注解方式可读性更高

相互注册的服务同步之后，不会向目标服务的peer同步。所以eureka官方也是推荐你配置的时候把所以的服务集群都写进去

**设计点**
收到服务实例信息之后，有各种事件配置，心跳时间、同步时间、续约时间、剔除时间。

eureka抽象成租约Lease，里面放置各种时间属性，和持有的服务实例Holder。

这样设计其实和eureka的业务有关系，因为它后面频繁的续约会更改租约中的时间属性值，这样不会影响其中的instance实例

日均几十W次，一秒可承受至少1000的并发，用的concurentHashMap put 

## java基础

~~~java
        String url = configService.mapServiceUrl() + "/distance?";
        Map<String, Object> map = new HashMap<>();
        map.put("originLongitude", distanceRequest.getOriginLongitude());
        map.put("originLatitude", distanceRequest.getOriginLatitude());
        map.put("destinationLongitude", distanceRequest.getDestinationLongitude());
        map.put("destinationLatitude", distanceRequest.getDestinationLatitude());
        String param = String.join("&", map.keySet().stream().map(k -> k + "={" + k + "}").collect(Collectors.toList()));
        url = url + param;
~~~







## 复习

2.3.21.3. 执⾏ execute()⽅法和 submit()⽅法的区别是什么呢？

谈谈AQS

2.4.9. 如何判断⼀个类是⽆⽤的类?

 Cookie的作⽤是什么?和Session有什么区别？

MyISAM和InnoDB区别

一条SQL语句在MySQL中如何执行的

11. Redis是如何判断数据是否过期的呢？

缓存穿透解决方案

这个 Dao 接⼝的⼯作原理是什么？Dao 接⼝⾥的

session cookie

token

## 一致性哈希、哈希槽