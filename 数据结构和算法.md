## 基础知识

### 复杂度

常数操作

固定时间：
32位以内的数字计算时间是固定的。
数组中找元素几乎是固定时间，因为只需要怼一个偏移量
而链表则不是

#### **时间复杂度**

把操作分解到常数时间操作
只需要最高阶的次数
这样可以判断出样本量很大时的时间复杂度



#### **额外空间复杂度**

用户要求的不算，如要求返回一个数组，则次数组不算额外空间



#### 算法比较

时间复杂度比完比常数时间，此时直接跑数据分析，因为常数操作时间是不好估计的。



```java
public class InsertCount {
    public static void main(String[] args) {
        int[] arr = {2,5,3,9,6,7,4};
        if (arr == null || arr.length <2){
            return;
        }
        for (int i = 1; i < arr.length; i++) {
            for (int j = i-1; j>=0 && arr[j]>arr[j+1] ; j--) {
                swap(arr,j,j+1);
            }
        }
    }
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```



## 二分法

mid = (L + R) / 2 不安全，数据可能溢出。

mid = L + (R - L) >> 1

> L，R都没溢出，但是加到一起就溢出了





### 对数器

比较输入的数组是否相等依次判断以下几项
其一为空，都为空，长度相等，逐一比较
要先判断length,减少比较的次数

~~~java
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		// Math.random() -> [0,1) 所有的小数，等概率返回一个
		// Math.random() * N -> [0,N) 所有小数，等概率返回一个
		// (int)(Math.random() * N) -> [0,N-1] 所有的整数，等概率返回一个
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; // 长度随机
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}
~~~





## 异或运算^

相同为0，不同为1
无进位相加

运算结果无关顺序

只能针对不同内存位置的数，对于同一位置，会将其刷成0

### 例题

#### 寻找奇数次

只有一个数出现了奇数次。找出它

只需申请一个空间即可。

全部与一个数^,因为交换律和结合律，偶数的全部抵消

#### 只取最后一个1

取反+1  (~number)    取反+1等同于加负号
再和原来的^

#### 寻找2个奇数次



## 数据结构

### 双向链表

~~~java
public static DoubleNode{
    public int value;
    public DoubleNode last;
    public DoubleNode next;
    
    public DoubleNode(int data) {
        value = data
    }
}
~~~

### 栈和队列

* 用栈实现队列
  * 用两个栈，每次操作后从A栈倒腾进B栈

### 递归

#### Master公式

T(N) = a* T(N/b) + O(N^d)

取logba 和 d 相对较大的那个



### 哈希表

put时原生类  按照引用传递

* 原生类型自动实现排序
* 引用类型需实现compare接口

## 归并排序相关

* 比左边大或小之和，核心在于merge的时候，两边的数组是有序的，所以可以更加便捷的达成一些操作。

### 区间和的个数

* 求数组中任意两个位置的区间和，可以生成一个辅助数组，因为 [3,9]的区间和就等于[0,9]-[0,2]



## 有序表



### 比较器

compare方法里遵循一个规范
返回负数的时候，认为第一个参数应该排前面 

~~~java
   public static class AgeUpIdDownOrder implements Comparator<Student> {
        //age升序，id降序
        @Override
        public int compare(Student o1, Student o2) {
            return o1.age != o2.age? o1.age - o2.age : o2.id - o1.id;
        }
    }
~~~

### TreeMap

~~~java

~~~

### 大根堆

任一节点的父节点在 i-1/2的位置

### 删除堆上最大数

从0开始找较大的孩子，和它换位置。换完继续和下面的孩子比



