# JAVA基础

### JDK8有哪些新特性

我列举一下我用到的。

最大的改动就是lamda表达式，然后是新增的时间类**LocalDateTime**

### 为什么要用LocalDateTime

Date如果不格式化，打印出的日期可读性差。如果用SimpleDateFormat对时间进行格式化，但SimpleDateFormat是线程不安全的



### 1.重写和重载区别

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。



  重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
  重载(overloading) 是在一个类里面，方法名字相同，而参数列表不同（参数类型，参数个数和参数顺序不同）。返回类型可以相同也可以不同。
  方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。

### 2.== 和 equals 的区别

**== 解读**

对于基本类型和引用类型 == 的作用效果是不同的，如下所示：

- 基本类型：比较的是值是否相同；
- 引用类型：比较的是引用是否相同；

**equals 解读**

equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。

### 3.final在java中的作用，有哪些用法?

1. 被final修饰的类不可以被继承

2. 被final修饰的方法不可以被重写

3. 被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变. 

4. 被final修饰的方法,JVM会尝试将其内联,以提高运行效率

5. 被final修饰的常量,在编译阶段会存入常量池中

### 4.String、StringBuffer和StringBuilder区别

* String是只读字符串，从底层源码来看是一个用final类型的字符数组。所引用的字符串不能跟变，每次对String的操作都会形成新的String对象
  * 每次+操作：隐式得在堆上new了一个跟原字符串相同StringBuilder对象，再调用append方法拼接后面的字符。

* StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。

* 在所有的情况下选择使用 **stringbuiler**，除非你真的遇到了一个需要线程安全的场景.

 stringbuffer 的线程安全，仅仅是保证 jvm 不抛出异常顺利的往下执行而已，它可不保证逻辑正确和调用顺序正确。



String是只读字符串，从底层源码来看是一个用final类型的字符数组，每次对String的操作都会形成新的String对象。因此想要操作的字符串经常改变时，会选择

### 5.讲下java中Math常用方法

Pow()：幂运算

Sqrt()：平方根 

Round()：四舍五入 

Abs()：求绝对值 

Random()：生成一个0-1的随机，左闭右开。

### 6.String类的常用方法有那些？

charAt：返回指定索引处的字符 

indexOf()：返回指定字符的索引 

replace()：字符串替换 

trim()：去除字符串两端空白 

split()：分割字符串，返回一个分割后的字符串数组 

getBytes()：返回字符串的byte类型数组 

length()：返回字符串长度 

toLowerCase()：将字符串转成小写字母 

toUpperCase()：将字符串转成大写字符 

substring()：截取字符串 

format()：格式化字符串 

equals()：字符串比较

### 7.Hashcode的作用

hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；

如集合Set中的存储的是无序唯一的数据，插入数据时判断是否重复调用equals方法查询比较慢。hashcode可以提高集合中查找元素的效率，它根据对象的内存地址换算出一个值，当添加新元素时先根据它的哈希值放到指定位置上，再调用equals判断在当前位置是否重复，提高了效率。

### 8.Java创建对象有几种方式？

java中提供了以下四种创建对象的方式：
1.new创建新对象
2.通过反射机制
3.采用clone机制
4.通过序列化机制

### 9.静态内部类

.Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap内部维护Entry数组用了存放元素，但是Entry对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。

### 10.说出一些常用的类，包，接口

常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer

常用的包：java.lang java.awt java.io java.util java.sql

常用的接口：Remote List Map Document NodeList

### 94.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？



### 12.抽象类和接口有什么异同

​	抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。

​	接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是**private**、默认、protected、public的，而接口中的成员全都是public的。

​	抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。

### 13、抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被 synchronized修饰？

都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的**实现细节**有关，抽象方法不涉及实现细节，因此也是相互矛盾的。



### 14、为什么重写equals方法后要重写hashcode

因为如果重写equals意味着你想要以自己的方式去比较数据，如果不重写的话，当数据存放在hashmap中时是按照原来的hashcode去判断的。



### =多态

### java常用的包

lang
io
sql
util
awt
net
math

### String常用方法

charAt: 返回指定索引处字符

indexOf() 返回指定字符的索引

length

split 分割字符串

trim 去除两端空白

# Spring===

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1599047126824&di=39225eb78eddd211065f5c46f1d81b59&imgtype=0&src=http%3A%2F%2Fww4.sinaimg.cn%2Fmw690%2F7178f37egw1etwb5nakx1j20k00f0dhy.jpg)

### 1.什么是Spring Framework？

Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。它是轻量级、松散耦合的。它具有分层体系结构，允许用户选择组件，同时还为2EE应用程序开发提供了一个有凝聚力的框架。它可以集成其他框架，如Structs、Hibernate、EJB等，所以又称为框架的框架。

### 2.Spring有哪些不同的功能？

轻量级 - Spring 在代码量和透明度方面都很轻便。

IOC - 控制反转	

AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。

MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。

事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。JDBC 异常 - Spring的 JDBC 抽象层

提供了一个异常层次结构，简化了错误处理策略。

**Spring 核心容器**-该层基本上是Spring Framework的核心。它包含以下模块：
口Spring Core

口Spring Bean

口SpEL（Spring Expression Language）
口Spring Context

### 3. 为什么要使用 spring？

**1.简介**

- 目的：解决企业应用开发的复杂性
- 功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能
- 范围：任何Java应用

简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。

**2.轻量**　

从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。

**3.控制反转**　　

Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。

**4.面向切面**　　

Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。

**5.容器**

Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。

**6.框架**

Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。

所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。



### 4. 解释一下什么是 ioc？

IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。

原本对象A在初始化或运行到某点的时候需要对象B，此时它主动去创建B，而加入IOC容器之后，当对象A运行到需要B的时候，IOC容器会主动创建B提供给A





1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。

IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTzZqaWI4WFAzcjhoOHNpYjA4MGljaWJIdnVtVVdIazdWVkJxNU81V2dXajFRRlFCUFdsamxqNUNpYnNVeDZmcDRiN0xRaHZOSm1HTjZ2NzNBLzY0MA?x-oss-process=image/format,png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。

我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTzZqaWI4WFAzcjhoOHNpYjA4MGljaWJIdnVQanlJaWN2bzVkNm5Jc2NoakVtaWM2aHlSeXIySTlJY3ZNR1IwMXVQOERCQmhFNHpWWlU0ZnJNUS82NDA?x-oss-process=image/format,png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！

我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：

软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。

软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。

通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。

### 5. 解释一下什么是 aop？

AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。

而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，**就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度**，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。

使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如**权限认证、日志、事务处理**。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”

6.@RequestMapping 注解有什么用？

@RequestMapping 注解用于将特定HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：
类级别：映射请求的URL方法级别：映射URL以及HTTP请求方法

### 项目中用到AOP

灰度发布、日志、统计、qps

### 7、Spring Bean 的生命周期？

![](E:/deng/deng/MD/spring/image/bean生命周期.png)

总结：

**（1）实例化Bean：**

对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。

**（2）设置对象属性（依赖注入）：**

实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。

**（3）处理Aware接口：**

接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：

①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；

②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。

③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；

**（4）BeanPostProcessor：**

如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。

**（5）InitializingBean 与 init-method：**

如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。

**（6）如果这个Bean实现了BeanPostProcessor接口**，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；

以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。

**（7）DisposableBean：**

当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；

**（8）destroy-method：**

最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。

### 8、Spring AOP的实现原理？

​		Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。

​		Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。

​		如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。

### 9. 说一下 spring 的事务隔离？

事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：

- 脏读：一个事务读到另一个事务未提交的更新数据。
- 幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。
- 不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。

### 10、Spring 的不同事务传播行为有哪些，干什么用的？

![传播特性](E:\deng\image\传播特性.jpg)

| 传播属性     | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| REQUIRED     | 如果此方法外层有事务在运行，那当前方法就归属于外层的事务，否则启动新的自己的事务 |
| REQUIRED_NEW | REQUIRED_NEW中报错时，会导致另一个REQUIRED回滚（外层捕捉到了异常，）<br />REQUIRED报错时，另一个REQUIRED_NEW不会回滚。 |

### 11、Spring通知有哪些类型

（1）前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。

（2）返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。 

（3）抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。 

（4）后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 

（5）环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 环绕通知是最常用的一种通知类型。



### 12.AOP两种代理方式

Spring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理。

**JDK** **动态接口代理**

\1. JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。

InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。利用构造函数生成动态代理类的实例对象，在调用具体方法前调用invokeHandler方法来处理。

**CGLib** **动态代理**

CGLib 全称为 Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展 Java 类与实现 Java 接口，CGLib 封装了 asm，把被代理对象类的class文件加载进来，修改其字节码生成子类。

和 JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例，

而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理。 CGLIB动态代理的原理是生成目标类的子类, 这个子类对象就是代理对象, 代理对象是被增强过的.

### 13.Spring中有哪些不同的通知类型

通知(advice)是你在你的程序中想要应用在其他模块中的横切关注点的实现。Advice主要有以下5种类型：

1. **前置通知(Before Advice)**: 在连接点之前执行的Advice，不过除非它抛出异常，否则没有能力中断执行流。使用 `@Before` 注解使用这个Advice。
2. **返回之后通知(After Retuning Advice)**: 在连接点正常结束之后执行的Advice。例如，如果一个方法没有抛出异常正常返回。通过 `@AfterReturning` 关注使用它。
3. **抛出（异常）后执行通知(After Throwing Advice)**: 如果一个方法通过抛出异常来退出的话，这个Advice就会被执行。通用 `@AfterThrowing` 注解来使用。
4. **后置通知(After Advice)**: 无论连接点是通过什么方式退出的(正常返回或者抛出异常)都会执行在结束后执行这些Advice。通过 `@After` 注解使用。
5. **围绕通知(Around Advice)**: 围绕连接点执行的Advice，就你一个方法调用。这是最强大的Advice。通过 `@Around` 注解使用

### 12、自动装配的注解@AutoWired，@Resource

​		在使用自动装配的时候，出了可以使用@AutoWired注解之外，还可以使用@Resource注解，大家需要知道这两个注解的区别。

​		1、@AutoWired:是spring中提供的注解，@Resource:是jdk中定义的注解，依靠的是java的标准

​		2、@AutoWired默认是按照类型进行装配，找不到则通过名字查找，默认情况下要求依赖的对象必须存在，@Resource默认是按照名字进行匹配的，同时可以指定name属性。

​		3、@AutoWired只适合spring框架，而@Resource扩展性更好

### SpringBean生命周期

**实例化**
1.实例化一个Bean，也就是我们常说的new。
**IOC依赖注入**
2.按照Spring上下文对实例化的Bean进行配置，也就是IOC注入。
**setBeanName 实现**
3.如果这个Bean 已经实现了BeanNameAware接口，会调用它实现的setBeanName（String）方法，此处传递的就是Spring配置文件中Bean的id值
**BeanFactoryAware 实现**
4.如果这个Bean 已经实现了BeanFactoryAware接口，会调用它实现的 setBeanFactory，setBeanFactory（BeanFactory）传递的是Spring 工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）。

**ApplicationContextAware 实现**
5.如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext（ApplicationContext）方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）

**postProcessBeforelnitialization 接口实现初始化处理**
6.如果这个Bean关联了BeanPostProcessor接口，将会调用
postProcessBeforelnitialization（Object obj，String s）方法，BeanPostProcessor 经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。
**init-method**
7.如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。
**postProcessAfterlnitialization**
8.如果这个Bean关联了BeanPostProcessor接口，将会调用
postProcessAfterlnitialization（Object obj，Strings）方法。
注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton。
**Destroy 过期自动清理阶段**
9.当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的 destroy0方法；

**destroy-method 自配置清理**
10.最后，如果这个Bean的Spring配置中配置了destroy-method 属性，会自动调用其配置的销毁方法。



### spring常用注解

@Controller
@RestController
@Service
@ResponseBody
@RequestMapping
@Autowire
@PathVariable



### 源码



# MVC===

![](E:\deng\deng\MD\image\springmvc运行流程.jpg)

### 1、什么是MVC？

​		MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。就是将业务逻辑、数据、显示分离的方法来组织代码。MVC主要作用是**降低了视图与业务逻辑间的双向偶合**。MVC不是一种设计模式，**MVC是一种架构模式**。当然不同的MVC存在差异。

​		**Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。

​		**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。

​		**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。



### 2.执行流程

```
1、DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。
2、HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。
3、处理器映射器返回处理器执行链，根据url查找控制器，并且将解析后的信息传递给DispatcherServlet
4、HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。
5、执行handler找到具体的处理器
6、Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。
7、HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。
8、DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。
9、视图解析器将解析的逻辑视图名传给DispatcherServlet。
10、DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图，进行试图渲染
11、将响应数据返回给客户端
```

### 3.Spring MVC常用的注解有哪些？

**@RequestBody**

用于获取请求体内容。直接使用得到是key=value&key=value..结构的数据。

**@RequestMapping**

一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响g应请求的方法都是以该地址作为父路径

**@ResponseBody**

该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。返回的数据不是htm标签的页面，而是其他某种格式的数据时（如json、xm等）使用

**@RequestParam**

主要用于在SpringMVC后台控制层获取参数。

**@ModelAttribute**

在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法

在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数 –绑定到对象中，再传入入参将方法入参对象添加到模型中

**@SessionAttribute** 

用于多次执行控制器方法间的参数共享。



# springBoot

### 为什么要用boot

spring和mvc需要配置大量的参数
而springboot可自动默认配置

通过starter来加载



### 需要独立容器运行吗

自带了Tomcat/Jetty等容器



### @SpringBootApplication 注解中的属性相当于哪几个注解？ 

等价于下面三个注解，完成自动装配

* @Configuration，	spring中标注为配置类

* @ComponentScan。spring中将指定包下需要装配的组件注册到容器中
* @EnableAutoConfiguration 

其实就是springboot通过配置文件自动装配所属依赖的类，再用动态代理的方式注入到spring容器中

# mysql

### 1.锁机制

**锁是计算机协调多个进程或线程并发访问某一资源的机制。**

不同的**存储引擎**支持不同的锁机制，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

​	**表级锁：**开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 
​	**行级锁：**开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  

表级锁更适合于以查询为主，有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用

#### MyISAM表锁

MySQL的表级锁有两种模式：**表共享读锁（Table Read Lock）**和**表独占写锁（Table Write Lock）**。  

### 2.InnoDB与MyISAM的区别

![存储引擎](E:\deng\image\存储引擎.png)

1.InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
2.InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；
3.InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
4.InnoDB不保存表的具体行数，执行select count（*）from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
5.Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高

### 3.索引

![数据库流程](E:\deng\image\数据库流程.png)

帮助Mysql高效获取数据的排好序的**数据结构**

索引是放在磁盘里的，使用时才读取到内存里。读取速度需要考虑，磁盘预读长度一般为页（page）的整数倍

索引文件的存储形式与存储引擎有关

加速对表的查询，通过快速路径访问方法快速定位数据，减少了磁盘的IO

但降低数据插入、修改和删除的性能





### 读写分离与主从复制

主从复制为了解决并发访问数据库压力大的问题

![](E:\deng\image\database\主从原理.png)



读写分离经由代理

主写 副读

![](E:\deng\image\database\读写分离.jpg)

​		MySQL读写分离能提高系统性能的原因在于：

​		1、物理服务器增加，机器处理能力提升。拿硬件换性能。

​		2、主从只负责各自的读和写，极大程度缓解X锁和S锁争用。

​		3、slave可以配置myiasm引擎，提升查询性能以及节约系统开销。

​		4、master直接写是并发的，slave通过主库发送来的binlog恢复数据是异步。

​		5、slave可以单独设置一些参数来提升其读的性能。

​		6、增加冗余，提高可用性。

#### amoeba

### 事务隔离级别

读未提交，会出现脏读，即会读到未提交的数据

读已提交，会出现不可重复读，即在同一个事务中多次读取数据出现不一致的情况

可重复度，会出现幻读，a执行事务时，b新插入了一条数据，a虽然读不到数据，但不允许重复插入，也就是幻读

序列化，没有问题。

### 6、InnoDB与MyISAM的区别

1.InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语句组成一个事务提交；
2.InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；
3.InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
4.InnoDB不保存表的具体行数，执行select count（*）from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
5.Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高

### 索引的数据类型

要说为什么选择B+树作为索引，先说说其它的数据结构为什么不行

首先是哈希表，它更适合做等值查询，因为一个数据索引对应着唯一的hash值，hash表中的数据为无序数据，范围查找的时候非常浪费时间，而企业中更多使用范围查询，并且查询时必须将全部数据加载到内存，因此pass

然后是二叉树，使用二叉树的话容易出现树身过长的情况，影响查询效率。

AVL树的话，插入元素时会进行N次的旋转，严重影响插入的性能。

红黑树的话，虽然通过牺牲部分查询性能，提高了插入性能，但是树深仍无法控制

然后到B树，b树的磁盘块中包含了指针、键值和数据，如果数据的体积比较大，就会导致树身增大，从而间接增加了IO的次数，影响查询性能

因此最后是选择的B+tree，

### 索引

索引是帮助mysql高效获取数据的数据结构。

主要有4中索引

主键索引（PRIMARY）
唯一索引（UNIQUE）
普通索引（INDEX）
全文索引（FULLTEXT）

索引并不是越多越好，因为创建索引也会耗费资源，并且需要花费较多的时间维护。

### 索引难点

**回表**

比如用创建索引的是其它字段（比如name）时，叶子节点中放的是主键，再根据主键索引找数据

因此经过两次遍历 

> 这么设定的原因在于，如果普通索引也放置数据，那么就需要解决数据一致性的问题

**覆盖索引**

如果查询的值为索引内容，则成为覆盖索引

* 使用**覆盖索引**优化回表问题
* select id from emp where name ="";
* select id 而不是*，name的B+树中就有id，直接找到，不会发生回表

**最左前缀**



**最左匹配**

组合索引 只有在搜最左的数据时才生效

**索引下推**

select * from table where name="zhangsan" and age=10

普通情况下先通过张三找到对应的主键，再通过主键找到age返回信息

索引下推时，匹配name的同时匹配age=10的情况，只将"zhangsan" and age=10的数据主键返回

### 71、如何通俗地理解三个范式？ 

第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解； 第二范式：2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 第三范式：3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 范式化设计优缺点: 优点: 可以尽量得减少数据冗余，使得更新快，体积小 缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引 优化 反范式化: 优点:可以减少表得关联，可以更好得进行索引优化 缺点:数据冗余以及数据异常，数据得修改需要更多的成本 



### mysql可以从哪些方面优化

# Mybatis

### mybatis的优点

1. 基于sql语句编程，较为灵活。sql是写在XML中的，与程序代码解耦，便于管理



### 6、#{}和{}的区别是什么？ 

#{}是预编译处理，​ ${}是字符串替换。 

Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的set 方法来赋值； 

Mybatis 在处理${}时，就是将其替换成变量的值。 使用#{}可以有效的防止 SQL 注入，提高系统安全性 

# 网络

### 1.tcp和udp的区别

网络五层协议体系结构：**物理层、数据链路层、网络层、传输层、应用层**

在传输层中有TCP协议与UDP协议。

TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，简单概况就是：

\1. 主机A向主机B发出连接请求数据包

\2. 主机B向主机A发送同意连接和要求同步的数据包

\3. 主机A再发出一个数据包确认主机B的要求同步

而UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！

### 2：tcp连接建立的时候3次握手，断开连接的4次挥手的具体过程

建立连接采用的3次握手协议，具体是指：
    第一次握手是客户端connect连接到server；server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了，这是第二次握手；第3次握手就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。
断开连接的4次握手,具体如下：
    断开连接的一端发送close请求是第一次握手（一般是客户端）；另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手，发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手，而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认。

# 多线程

### 1.notify()notifyAll()有什么区别？

notify可能会导致死锁，而notifyAll则不会

任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 中的代码

使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。

wait() 应配合while循环使用，不应使用if，务必在wait()调用前后都检查条件，如果不满足，必须调用

notify()唤醒另外的线程来处理，自己继续wait()直至条件满足再往下执行。

notify() 是对notifyAll()的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死

锁。正确的场景应该是 WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果

唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到WaitSet中. 

### 2.sleep（）和wait（）有什么区别？

1.对于sleep（）方法，我们首先要知道该方法是属于Thread类中的。而wait（）方法，则是属于Object类中的。
2.sleep）方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态
3.在调用sleep）方法的过程中，线程不会释放对象锁。
4.而当调用wait）方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify（）方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

### 3.为什么wait，notify 和notifyAll这些方法不在thread类里面？

原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需

要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们

定义在Object类中因为锁属于对象 。



### =5.简述一下你对线程池的理解

第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控

### 6.Synchronized 同步锁

synchronized 它可以把任意一个非NULL的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。Synchronized作用范围**
1.作用于方法时，锁住的是对象的实例（this）；
2.当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个==全局锁==，会锁所有调用该方法的线程；
3.synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。



### =说一说自己对于synchronized 关键字的了解

synchronized关键字解决的是多个线程之间访问资源的==同步性==，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

另外，在Java早期版本中，synchronized属于重量级锁，需要找操作系统内核申请锁，涉及用户态和内核态的转换，效率低下。

jkd6之后，首先是首先是**偏向锁**，markword 记录这个线程ID，提高单个线程执行同步块时的性能（二进制的头两位,00代表无锁，01代表偏向锁，10轻量级锁，11重量级锁）
如果线程争用，升级为**自旋锁**（循环判断是否能拿到锁，占用cpu，但是不访问操作系统，只在用户态解决）
默认是自旋10次后升级为**重量级锁-OS**，进入等待状态，不占用cpu(状态不可退回，但虚拟机也可以实现)



### Synchronized小问题

Synchronized 方法可以和普通方法同时运行
如写操作上锁而读操作不上锁，可能会出现脏读问题，读也加锁可解决

Synchronized对象属性可以改变，但对象引用不能改变，因此需要加final

### 7.=Java线程池工作过程

1.线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。
2.当调用execute）方法添加一个任务时，线程池会做如下判断：
a）如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；b）如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；c）如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；d）如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException。
3.当一个线程完成任务时，它会从队列中取下一个任务来执行。
4.当一个线程没有任务，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。

### 8.什么是Callable和Future？

Callable 接口类似于Runnable，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法

抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。可以认为是带有回调的Runnable。
Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。

### 9.api方法

**join** : 让当前线程在指定线程运行结束后运行，比如主线程需要子线程的计算结果，但是子线程运行较为耗时，此时就需要用到join，让主线程等待子线程运行结束再继续运行

**yield：**暂停当前正在执行的线程对象，并执行其他线程。会先检测当前是否有相同优先级的其它线程，有就交给它，否则继续运行。也有可能继续抢到cpu

**stop:**废弃，过于粗暴。

### 线程有几种实现方式，并且哪种好

* 继承*Tread*类,重写run方法
* 实现*Runable*接口
  * new Thread(new Runable()).start
  * new Thread(()->{sout("hello，thread");}).start
* 实现callable接口（有返回值）

runnable优势

1）：适合多个相同程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类

）：----增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

### 线程的生命周期

**新生状态：**指创建好线程，还没有调用start方法

**就绪状态：**线程调用了start方法，变为可运行状态，等待获取cpu的使用权

**运行状态：**指当前线程抢占到了cpu资源，执行程序代码

**阻塞状态：**指运行过程中出现了异常导致无法继续运行，将进入阻塞状态，阻塞的原因消除后会再次进入就绪状态。

阻塞的原因有：
等待阻塞：线程调用了wait方法，jvm会把该线程放入等待池中（wait会释放持有的锁）
同步阻塞：运行的线程在获取对象的同步锁时，锁被占用，jvm会把该线程放入锁池中
其他阻塞：比如执行了sleep、join方法，或者是发出了IO请求。

**死亡状态：**



### 谈谈volatile作用

1.保证线程可见性

一个线程修改了某个变量的值，这个新值对于其他线程是立即可见的。

不同线程到公共堆中取值，是先copy到自己的空间再改变，再写回公共空间。因此两个线程使用的数据不能够及时共享。加上volatile后，不同线程就能及时感知到数据的变化。实际底层根据了cpu的 MESI 缓存一致性协议，毕竟如果读取过程中又被改了，还是需要硬件层面来保证。

2.禁止指令重排序

单例模式双重检查的写法

因为对象的初始化过程是先给成员变量赋予默认值，然后再赋予初始值，那么在赋予默认值之后，这个对象就已经不为空了，那么此时另外一个线程过来判断INSTANCE不为空，直接用了默认值，就出问题了。





### =CAS

cas又叫乐观锁、自旋锁、无锁优化，是Compare And Set
判断当前值是否和期望值相同，如果相同就将其设置为新值。

这个会出现ABA问题，如果是基础类型的话没有影响，但是引用类型会有影响。引用没变，但是内容变了。增加版本号可以解决这个问题

内部利用了Unsafe类实现cas操作，
有印象，具体记不清了。

### 不同并发方案时间比较

升级后的Synchronized效率并不一定就比其它的方法低。

### 各种JUC同步锁

**synchronize**

**ReentrantLock**

比Synchronized更灵活，特点是必须手动解锁，因此一般放在finally中执行。它也是可重入锁。并且它可以设置公平锁。默认是非公平锁，新来的线程和前面来的线程有同等的竞争力

**CountDownLatch**

需要设置门栓数量，调用await方法后，必须通过countDown()方法将门栓数量减为0才能够继续执行

**CyclicBarrier**

需要先设置一个数量，必须调用await()达到这个数量，才能执行runnable中的代码

场景：一个复杂操作需要其它各个操作完成再执行。那么在并发场景下，其它操作调用await



**读写锁**



**Semaphore**

先设置你想要限制的同时运行的线程数量

 `acquire()`阻塞获取锁，成功就-1，最后再`release()`,再+1.
这样就可以控制同时运行的线程数量。

默认是非公平锁



**Exchage**

交换两个线程中的值



**LockSupport**

无需synchronize锁住某个目标（或调用wait），就可以实现对线程的阻塞等控制

LockSupport.park

LockSupport.unpark (t)		

它的特点是unpark可以先于park调用,不像notify，必须wait以后调用

### 锁优化

* 采用细粒度的锁，尽量不要将无需锁的代码放入其中
* 当锁在一片区域比较密集的时候，可以粗化锁
* 锁分离。常见的就是读写锁

执行时间长，线程数量多用重量级（OS）锁
时间短，线程数量少用自旋锁（比如1个在执行，999个在自旋等待）

实际用起来synchronize也不慢

### =谈谈AQS

使用了模板方法、回调函数

锁的底层是AQS。我主要看的是ReentrantLock的实现，其他锁本质也是AQS。其中主要重要的是state，它是volatle的int类型，用于判断是否加锁，并且设置state的方法除了有setState,还有compareAndSetState。
所以有人称AQS底层就是volatile+CAS

state内部维护一个队列，是AQS的内部类，它是一个双向链表，它的节点node中装着Thread，没抢到锁的通过addwaiter方法进入队列。这个addwaiter方法是一个死循环，以cas的方式加载链表后。

### java的四种引用

强引用：

软引用：

弱引用：

虚引用：

### 谈谈ThreadLocal

ThreadLocal是线程独有的。

ThreadLocal中是用到弱引用的，线程中tl是强引用指向keyThreadLocal对象，ThreadLocal对象是作为ThreadLocalMap中的key,并且这个key是弱引用指向ThreadLocal。如果强引用的话会出现内存泄漏的情况。

* 在声明式事务中
  * 第一个拿到connection后，放入ThreadLocal中，后续的从local拿，这样不会使得拿到不同的connection。

### Executors

是线程的工厂，线程池的顶级接口。严格意义说的话它并不是一个线程池，而只是一个执行线程的工具。

### 线程池的参数有哪些

 **corePoolSize**：就是线程池中的核心线程数量 

**maximumPoolSize**：就是线程池中可以容纳的最大线程的数量

**keepAliveTime**：线程池中除了核心线程之外的其他的最长可以保留的时间

**TimeUnit.SECONDS**：时间单位

**workQueue（BlockingQueue）**：任务队列，任务可以储存在任务队列中等待被执行

**threadFactory**：就是创建线程的线程工厂（可自定义创建线程方式，默认的创建线程方式）

**handler**(RejectStrategy)：拒绝策略，jdk默认提供了4种，可自定义



### 自义线程池数量

需要看业务是计算密集型还是IO密集型。

实际还是需要压测来验证

### 功能线程池

大概有印象，但一般不用，都用自定义的。

### 拒绝策略

1. AbortPolicy ： 直接抛出异常，阻止系统正常运行。

2. CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的 任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。
3. DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再 次提交当前任务。 
4. DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢 失，这是最好的一种方案。 以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际 需要，完全可以自己扩展 RejectedExecutionHandler 接口

### 容器发展历史

* vector、hashtable 自带锁 （有缺陷，现在不用）
* hashmap 去除锁，增加效率
* synchronizeHashMap	增加加锁版本（性能也不比hashtable高多少）
* concurrentHashMap	多线程专用
  * 读效率很高，但写效率跟上面几个差不多
  * 但是没有concurrentTreeMap,因为树实现cas太复杂了
  * 但又需要一个排好序的容器，因此产生了 如下
* concurrentSkipListMap 跳表
  因为concurrentTreeMap不好实现，又需要一个排好序的便于查找
  先从顶层查找，依次向下

### 阻塞队列

queue提供了这些对多线程友好的操作

**ArrayBlockingQueue ：**由数组结构组成的有界阻塞队列。



**LinkedBlockingQueue：**基于链表的阻塞队列

`take()`自带阻塞，线程数最大值是INTEGER最大值

 **PriorityBlockingQueue ：**支持优先级排序的无界阻塞队列。







**SynchronizeQueue：**不存储元素的阻塞队列。

这个队列是空的，不能在里面放东西，只能1先take()在那阻塞，等着2去take()。相当于两个线程手把手交换。

**TransferQueue：**strs.transfer("aaa"),必须有结果才会离开

MQ底层就是用这种逻辑，比如，确认用户的订单得到了处理
当你自己去实现mq的效果时就需要用这个了



### 9、sleep（）和wait（）有什么区别？

sleep方法是属于Thread类中的，而wait方法是属于object类中的。
sleep不会释放锁，而wait会释放锁

### Thread 类中的start() 和 run() 方法有什么区别？

start()方法被用来启动新创建的线程，且start()内部调用了run()方法。
当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动。

### 为什么wait, notify 和 notifyAll这些方法不在thread类里面？

这个明显就说明java提供的锁是对象级别的，而不是线程级别的，每个对象都有锁。
如果wait方法定义在Thread类中，那么线程正在等待的是哪个锁就不明显了。

### =15、Java中synchronized 和 ReentrantLock 有什么不同？

这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配 合try/finally语句块来完成。

ReentrantLock类提供了一些高级功能，主要有以下3项：

1.等待可中断
2.公平锁

### =20、Java线程池中submit（）和execute（）方法有什么区别？

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而 submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了 Executor接口。

### 25、简述一下你对线程池的理解

第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 

第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系 统的稳定性，使用线程池可以进行统一的分配，调优和监控 

### 进程

指一个程序运行的实例，一个进程可以有多个线程，这些线程共享同一地址空间。

### 86、线程与进程的区别？

进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。

 一个程序至少有一个进程,一个进程至少有一个线程。

### 死锁

死锁是指两个或以上的线程在执行过程中因争夺资源而互相等待的现象。

### =89、Java 中用到的线程调度算法是什么？

采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。



### 92、在 Java 中 Executor 和 Executors 的区别？ 

Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 Executor 接口对象能执行我们的线程任务。 ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状 态并且可以获取任务的返回值。 使用 ThreadPoolExecutor 可以创建自定义线程池。 Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的 完成，并可以使用 get()方法获取计算的结果。





# JVM

### 你线上怎么调优的

运维团队收到报警信息，后台用 top 命令观察问题，jpsi查看具体的java进程，会重点关注：WAITING BLOCKED，jstack 查看线程信息，如果发现是GC的线程，那就去看GC日志。这个时候有意义的线程名称会方便排查。 jconsole/jvisualVM用于测试的时候看

线上一般会配这个·`-XX:+HeapDumpOnOutOfMemoryError`

用jmap -histo 1736 | head -20  命令打印出instances占用的空间信息

PS：你在线上系统执行这个命令，服务不踏马宕机了？

我们线上有多台服务器备分，做了高可用，停掉这台服务器不影响其他服务器

有时是数据库连接没有关闭占用资源，其他线程无法调用，等待超时，通过数据库日志定位

### 如何理解JVM

jvm是一种规范，它定义了java虚拟机能够执行什么，应该具备哪些模块，遇到不同指令应该做什么

任何语言只要能编译成class，符合class规范，就可以在java虚拟机上运行




### jvm编译执行流程

通过javac编译成class文件，此时jvm才可读。
调用java命令的时候class文件被装载到内存classloader，此时java类库也需要load到内存。
然后通过字节码解释器或即时编译器来解释或者编译，再由执行引擎执行，再下面就是OS硬件了。



### 对象创建过程

类加载分为三个步骤：loading、linking、initializing

首先是loading，jvm所有的class都是类加载器加载到内存的，也就是classloader。
然后采用混合模式去解析

第二步linking，

1. Verification
   1. 验证文件是否符合JVM规定、不符合的话就不进行下一步
2. Preparation
   1. 给静态成员变量赋默认值
3. Resolution
   1. 将类、方法、属性等符号引用解析为==直接引用==
      常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用

第三步Initializing，申请对象内存，成员变量赋予默认值，调用类初始化代码，给成员变量赋予初始值，执行构造方法语句



---

class被load到内存后创建了两块内容，第一块是把String.class二进制扔到内存中，第二块是生成一个class类的对象，这个对象指向第一块内容。

### 对象在内存中布局

**普通对象：**对象头8、classpoint指针4/8、实例数据4/8、Padding

**数组对象：**数组长度4

### 对象头中是什么



### 类加载器的类别

**BootstrapClassLoader（启动类加载器）**

`c++`编写，加载`java`核心库 `java.*`,构造`ExtClassLoader`和`AppClassLoader`。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作

**ExtClassLoader （标准扩展类加载器）**

`java`编写，加载扩展库，如`classpath`中的`jre` ，`javax.*`或者
 `java.ext.dir` 指定位置中的类，开发者可以直接使用标准扩展类加载器。

**AppClassLoader（系统类加载器）**

```
java`编写，加载程序所在的目录，如`user.dir`所在的位置的`class
```

**CustomClassLoader（用户自定义类加载器）**

`java`编写,用户自定义的类加载器,可加载指定路径的`class`文件

### 描述双亲委派机制

它主要是想达到两个目的。
1。防止重复加载同一个class
2。为了安全，保证核心class不被篡改

从上往下是BootstrapClassLoader、ExtClassLoader 、AppClassLoader、
CustomClassLoader。
它的执行流程可以从classloader的源码中看到，首先最下层的classloader会调用findInCache查看自己的自定义缓存中是否存在，没有的话再调用parent的loadClass方法，这样一层一层向上直到顶层的bootstrapClassloader。
如果它也没有在自己的自定义缓存中找到，就会调用findClass()来加载这个类。
如果没有找到再到下一级执行同样的流程，直到findClass()找到这个类。

### 自定义classloader的应用

tomcat、spring、JRebel热部署，都要classloader给手动load到内存中。

**如何实现？**
1.继承classloader
2.重写findClass方法
3.将自己的内容load进内存，用defindclass方法将二进制流转换为class类对象（这一步可以加密）



### 对象的生命周期

先去stack，放不下就放堆

### 常见的垃圾回收器

jdk诞生后就伴随Serial，单线程回收垃圾，需要忍受STW，现在基本不用。然后是PS+PO，多线回收垃圾。还有PN+CMS，PN是PS的变种，为了配合CMS的。



### 你jstack怎么用的

\

### 你是怎么定位OOM问题的？



### G1有什么变化

CMS时代的年轻代和老年代是两块物理上连续的内存，这就导致当内存变大的时候，无论你采用什么算法都难以高效地清理垃圾，因此到G1时代采用分而治之的思想，不再分为连续的区域



# SpringCloud



## 微服务

### 微服务是什么

微服务架构是一种架构模式，或者说是一种架构风格，将单一应用程序划分成一组组小的服务，每个服务独立运行，服务间相互协调配合。

服务间采用轻量级的通信机制互相沟通(通常是基于HTTP的RESTful API).

### 微服务优缺点

优点：独立开发、部署、运行，不与其它业务耦合。

缺点：需要处理分布式系统的复杂性。数据一致性，服务间通信成本。

## Eureka

### 什么是Eureka

Eureka：是Netflix的一个子模块，是一个RESTful风格的服务，用于服务发现和注册的基础组件，包括两个部分：服务器端、客户端

传统应用中，组件间的调用通过有规范约束的接口实现，但拆成微服务之后，每个微服务实例的网络地址可能动态变化，数量也会变化，此时需要一个中心化组件来进行服务的登记和管理。

**Server**是一个公共服务，为Client提供服务注册和发现的功能，维护注册到自身的Client的相关信息，同时提供接口给Client获取注册表中其他服务的信息

**Client**将自己的服务信息登记到Server上，这样其它服务可以发现自己，同时可以通过server获得其它服务的信息，同时内置了负载均衡器。

### 服务注册与发现详情

**server功能**

1. 注册：将微服务信息注册到注册中心。
   发现：查询可用微服务列表及其网络地址。

2. 服务注册表：记录各个微服务信息，例如服务名称，ip，端口等。

   注册表提供 查询API（查询可用的微服务实例）和管理API（用于服务的注册和注销）。

3. 服务检查：定时检测已注册的服务，如发现某实例长时间无法访问，就从注册表中移除。

**client功能**

1. 注册：每个微服务启动时，将自己的网络地址等信息注册到注册中心，注册中心会存储（内存中）这些信息。
2. 获取服务注册表：服务消费者从注册中心，查询服务提供者的网络地址，并使用该地址调用服务提供者，为了避免每次都查注册表信息，所以client会定时去server拉取注册表信息到缓存到client本地，这样即使eureka挂了，也能直接通过缓存中注册表的信息访问其它服务的端口。
3. 心跳：各个微服务与注册中心通过某种机制（心跳）通信，若注册中心长时间和服务间没有通信，就会注销该实例。
4. 调用：实际的服务调用，通过注册表，解析服务名和具体地址的对应关系，找到具体服务的地址，进行实际调用。

### eureka如何保证高可用

通过运行多个Eureka server实例并相互注册的方式实现。Server节点之间会彼此增量地同步信息，从而确保节点中数据一致。

* 1.Eureka 间互相独立
  * 优点：只要有一个活着，就可以运行
  * 缺点：请求会变多
* 2.Eureka 间需要通信数据，降低数据一致性，但提高可用性。

### 高级应用

Actuator监控，需要配置开启所有节点

可以通过api控制服务

### 续租原理

心跳是由client向server发起，可以节省sever的资源
默认是每30秒发送一次心跳来续租
如果服务器在**90秒**内没有看到更新，它将从其注册表中删除实例

### 客户端获取注册表详情

Eureka客户端从服务器获取注册表信息并将其缓存在本地。之后，客户端使用这些信息来查找其他服务。

之后会定期更新这个信息

节点信息在服务器中保存的时间更长(大约3分钟)

### 元数据

Eureka的元数据有两种：标准元数据和自定义元数据

自定义元数据可以自定义用来区分不同的服务

### 自我保护机制

默认情况下server如果在90s内没有收到服务端的心跳，就会将其注销。但是当出现网络波动的时候，大量服务无法正常通信，这个时候注销大量服务就十分危险。因此这个自我保护机制在每分钟续约数量小于总数的85%的时候会触发。

### 健康检查机制

client配置之后会将自己真正的健康状态传播到server

心跳没问题不代表服务没问题，在server的列表中status是UP的。服务中catch到问题通过actuator上报到server，关停服务

### eureka调优

* 快速下线：减少服务上下线的延时

* 三级缓存：
  * 注册信息有三级缓存 register，readWriteCacheMap，readOnlyCacheMap，后两者的数据是30s同步一次的。
  * 减少同步时间也能加快发现服务的速度
  * 因为我们并发压力不高，设置直接从readWriteCacheMap拿数据

* 服务更新： 先停止，再发送下线请求，因为先下线可能会续约

**client优化：**

* 实际工作中，要把后面的url随机打乱
  * 因为默认是访问第一个，如果都配置一样的，会使得第一个压力过大
  * eureka会相互注册，所以会共享
    因此新来服务只注册第一个，就会被全部共享

### 如何测算服务数量

20个服务每个服务部署5个，eureka client：100个。
1分钟200。
心跳，向server发送我们活着，一天几十万次（对server来说）

集群并没有扩大承受能力，是为了高可用

## Ribbon

### 简介

Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具

### 负载均衡策略

软件负载均衡分为：服务端（集中式），客户端。
最大的区别在于 ***服务端地址列表的存储位置，以及负载算法在哪里***。

在服务端负载均衡中，客户端节点只知道==单一服务代理==的地址，服务代理则知道所有服务端的地址。

而在客户端负载均衡中，==所有的客户端节点都有一份自己要访问的服务端地址列表==，这些列表都是从服务注册中心获取的；

## Hystrix熔断

### 简述hystrix

 hystrix是spring cloud的一个容错组件。

Hystrix实现了 超时机制和断路器模式。

添加@HystrixCommand，标记fallbackMethod

### 为什么要做熔断

在分布式系统下，微服务之间相互调用，但每个系统都无法百分之百保证自身运行不出问题。在服务调用中，很可能面临依赖服务失效的问题（网络延时，服务异常，负载过大无法及时响应）。因此需要一个组件，提供强大的容错能力，为服务间调用提供保护和控制。

### 什么是雪崩

简单来说就是由基础服务故障导致级联故障的现象。服务提供者不可用导致消费者不可用，并逐渐放大，不可用的服务越来越多。

​	每个服务 发出一个HTTP请求都会 在 服务中 开启一个新线程。如果下游的服务不可用，线程会阻塞住。并发量高的情况下，大量的阻塞线程占用大量的资源，将服务器的资源耗尽。

### hystrix的容错机制

1.为网络请求设置超时。

2.使用断路器模式。

### 断路器原理

服务调用失败率达到阈值（默认50%）会打开断路器，停止对该服务的调用。一段时间后变为半开模式，允许一个服务发送请求。成功则关闭断路器，失败则打开断路器

### 如何实现降级

用fallback方法代替主方法执行并返回结果，对失败的服务进行降级。

断路器打开后会直接执行fallback

比如网约车中的计价服务，做了熔断，如果服务出现问题就返回默认10块



## zuul网关

### 简介

Zuul是Netflix开源的微服务网关，核心是一系列过滤器。这些过滤器可以完成以下功能。

身份验证、限流、负载均衡、动态路由

zuul默认集成了：ribbon和hystrix。

网关也可以做两层，流量网关和业务网关

拒绝策略最好前置，不然做很多无用功

### 4种过滤器

**PRE：**在请求被路由之前调用，可利用这种过滤器鉴权。选择微服务，记录日志，限流。
**ROUTE：**在将请求==路由==到微服务调用，用于构建发送给微服务的请求，并用http clinet（或者ribbon）请求微服务。
**POST：**在调用微服务执行后。可用于添加header，记录日志，将响应发给客户端。
**ERROR：**在其他阶段发生错误是，走此过滤器。



> 内部方法

**filterType：**pre，routing,post,error
**filterOrder:**执行顺序，越小优先级越高
**shouldFilter：**此过滤器是否执行，返回true就生效，可以写过滤器是否执行的判断条件。
**run：**具体执行逻辑。

### 网关如何限流

使用**RateLimiter**令牌桶工具

### 如何做高可用

一般前面加上nginx。



# Redis

### 为什么选择redis

大部分都是选择redis作为缓存，那么就要说为什么要用缓存。现阶段最大的限制就是IO瓶颈，全用内存又十分昂贵，因此缓存作为一个折中的选择。

redis和memcache都是k-v型，用于缓存，为什么选择redis?
因为redis的value有类型的概念，memcache是把value的所有数据返回到client，这样就需要client端再去解码，而redis可以调用类型指定的方法去取回数据，这是**计算向数据移动**的思想。

### redis为什么快

**运行过程：**多个client请求socket打到linux的kernel，redis进程和内核间使用的是epoll通信（多路复用）

虽然redis是单进程，单线程，单实例。
但是通过调用epoll，顺序处理数据，十分高效

### =IO发展历程

**BIO：**最开始是socket是阻塞的，==进程==读取文件描述符是阻塞式的，占用系统资源。

**同步非阻塞NIO：**单进程轮询read fd，轮询发生在用户空间，就不会出现多线程read而部分阻塞的问题。但如果需要轮询调用kernel的用户进程过多，涉及大量的用户态到内核态的转换，成本过高

**多路复用：**用户进程的请求一次发到kernel的select，由内核自己询问，可以访问的再返回给用户空间，用户空间再read。

**多路复用NIO：**调用epoll，多出了个共享空间，先存入红黑树，内核处理后放入链表，用户进程通过链表顺序读取

### 共享空间

用户空间和内核空间要传输数据，是为了安全考虑。为了增加效率，规定一块两者的共享空间mmap，内部是红黑树+链表

### 零拷贝

以往用户空间read内核，再write回内核，都需要拷贝。
而如果调用sendfile(out,in)。就会内核直接完成读写操作，这样就没有了来回拷贝的过程。



### redis数据类型

String/Byte、
List：调用不同命令可以实现栈和队列
hash map： 
Set
sorted_set

redis存储的key中包含着value和encoding

### 发布订阅怎么用的

pub sub

实时性的消息用发布订阅，并启用另一个client监听，通过kafka写入数据库
3天之内的消息通过sorted_set读取，更早的消息放数据库

### redis事务特点

mutli开启事务

因为redis是单进程的，两个client开启事务，先exec的先执行。

还可以用watch，实现乐观锁的作用
比如1想操作k1，那么先watch住k1，等到真正执行的是还看还是不是原来的k1，不是就取消操作



### 布隆过滤器解决缓存穿透

 用户搜索缓存中没有的数据，请求就会压到数据库上。
如果有人故意攻击，大量请求穿过缓存压到数据库上，就可能击垮数据库。

布隆将数据库中存在的元素通过n个不同的映射函数，映射到一个bitmap上。（不同元素是可能出现映射重叠的情况）。如果用户搜索的元素在数据库中存在，那么通过映射函数就一定能在bitmap上找到。

能大概率减少穿透，并且成本低。
布隆的算法和map可以自己选择放在哪里，redis集成更加合适，client轻量符合微服务架构

如果穿透过了布隆且数据不存在，client增加redis中的key，value标记不存在。下次请求就直接打到key.



### redis作为缓存和数据库的区别

缓存的数据相对来说是不那么重要的数据，它不是全量的数据，并且应该是根据访问变化的热数据



### redis作为缓存，数据如何更新

1.业务逻辑：自行设置过期时间 。。

2.内存限制



**主动：**redis每10秒随机检测key,并删除过期的key,直到过期key百分比低于25%
**被动：**访问时判断是否过期

牺牲内存，性能为王



### RDB工作方式

RDB持久化方式会在指定的时间间隔能对数据进行快照存储.

* save
  * 阻塞式快照
  * 基本只有关机维护的时候用
* bgsave
  * 调用内核的fork()并且利用内核写时复制的机制，创建子进程将数据写入临时的RDB，主进程之后修改数据实际上是写入其它的物理地址，而不是覆盖原来的地址。
* 配置文件设置bgsave的规则
  * save 900 1
    save 300 10
    save 60 10000
    从下往上，如果60s操作数达到10000，触发RDB

优点是 数据的恢复速度相对快，类似java序列化

### RDB优缺点

**优点**

* RDB是一个紧凑的单一文件，利于传输
* 父进程只需要fork出一个子进程，不需要再做其他IO操作，性能比较高
* 比AOF恢复快

**缺点**

* 不支持==拉链==（只有一个dump.rdb），需要运维定时拷贝
* 丢失数据相对多，因为只记录时点的数据，时点间的数据可能会丢

### 介绍AOF

AOF会将redis的写操作会记录到文件中。先在配置中改为yes开启AOF（默认是关闭的）

如果同时开启了RDB和AOF，只会通过AOF恢复。4.0后AOF包含RDB的全量，恢复流程是先恢复RDB再恢复AOF的追加写操作

* 优点在于它记录的数据较完整

* 弊端就在于，体量会无限增大，恢复数据会越来越慢。
  因此需要设计一些方案尽可能减少AOF文件的大小
  * 4.0以前通过重写的机制
    删除抵消的命令
    合并重复的命令
  * 4.0以后
    将老的数据RDB写入到AOF文件中，增量以指令的方式追加到AOF中
    重写后，AOF变为混合体，既利用了RDB的快，又有日志全量的优点
* 同时，写操作会触发IO，因此需要选择IO设置
  * everysec	默认是每秒
  * always    每一笔都flush   
  * no    由内核自己处理，buffer满了自动flush，可能会丢失一个buffer的数据
* 默认设置是AOF文件达到64M触发重写

### redis单机有什么问题，如何解决

redis单机会出现3个问题，可通过AKF思路解决

* 1.单点故障
  * 通过主从复制解决
    主机负责写，从负责读
    但每个都存着全量数据，仍然需要解决容量问题
* 2.容量有限
  * 按照功能业务划分不同的redis实例，如果划分业务容量又不足，可以按照优先级逻辑再拆分，比如1-1000,
  * module—哈希取模（twitter的实现）
  * random
  * kemata—一致性哈希
* 3.访问压力
  * nginx反向代理

### redis的主从复制会带来数据一致性问题，如何解决

大体上有三种解决方案

* 第一种是主机更新数据后，阻塞等待数据复制到从机。实现了强一致性，但是极大的破坏了可用性。
* 第二种是在redis主从之间加上kafka，因为响应速度快，可以阻塞写入kafka，再由kafka同步到其他redsi，保证最终一致性
* 第三种是异步同步到其它redis，弱一致性，可能会丢失数据。因为redis追求的是速度，实际上它是容忍了丢失数据的风险。



### Redis 集群的主从复制模型是怎样操作的？

5.0之后是replicaof 命令来追随主机

Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存，完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。 

### 主从集群中，从机重新启动后数据如何同步

从机挂掉重启后，是重新复制全量数据，还是复制增量数据？

主从同步是增量复制的

如果开启了AOF，会将主机的RDB重写为AOF。

### 主从复制有哪些配置项

replica-serve-stale-data yes	是否支持复制期间查询旧数据
replica-read-only yes				是否只读模式
repl-diskless-sync no				默认RDB是通过磁盘再同步，配置后直接通过网络发送RDB
repl-backlog-size 1mb			  配置内部维护的队列大小，过小会导致刷新速度过快。
#增量复制
min-replicas-to-write 3
min-replicas-max-lag 10

### 无论是主从还是主备，都存在主机，主机如何做==高可用==

sentinel集群 监控

高可用，也就是在主机故障的时候，自动转移到备机。但是这回带来一个新的问题，就是如何判断主机是不可用了。因为监控的程序它也是一个集群，也会有不可靠的情况。同时为了避免脑裂的情况，使用了半数以上的确认机制，并且是使用奇数台监控。（因为奇数和偶数承担的风险是一样的，但偶数多了一台的成本）

### Sentinal集群

使用Sentinal可以使主机自动完成故障转换

没有sentinel的时候， 主机挂掉需要自己重新去主从集群

配置sentinel后只需要监控主机，就可以感知到从机（联系到监控之间结合成势力，判定主机是否健在）



### 单节点解决容量问题有哪些方法

* 数据可以按照业务拆分，在客户端做分离，数据库本身是无感知的。
* module
  * hash取模划分数据。但是一开始需要确定模数（DB数量），影响分布式下的扩展性
* random
  * lpush顺序存，lpop顺序取
  * 一般用于做消息队列，key类似于topic
* kemata
  * 一致性哈希。
  * 优点：加节点可以分摊其他节点压力，并且不用重新洗牌
  * 缺点：新增节点会造成一小部分数据不能命中，出现击穿
    * 解决办法：尝试取最近的两个节点（增加复杂度）
  * 通过增加虚拟节点解决数据倾斜问题
    * hash计算后再加个数字
* 哈希槽

![分片算法](E:\deng\deng\MD\image\redis\分片算法.png)

### redis如果解决容量问题

使用cluster集群，引入了哈希槽的概念。

要说哈希槽，首先要说一下预分区的概念。（proxy直接hash取模一个较大的值，再均匀分配给不同的redis，迁移时只需要迁移指定的模数）

哈希槽在此之上更进一步，算法是在redis实例上的，取模后看是否在自己的mapping里，同时每个redis都知道其它redis的mapping，因此客户端随便连接到哪一台redis都可以知道需要的数据在哪

但是带来的问题是，对于数据的聚合操作很难实现。比如事务
因此需要客户端主动给key做标识 {ooxx}，使得hash后能到同一个redis

### redis还有哪些集群

predixy代理，

推特



### 击穿、穿透、雪崩

* **击穿：**指缓存中没有但数据库中有的数据，被并发访问，压到数据库上

  * 由于redis是单进程单实例，必然有第一个访问的，在客户端写逻辑，如果redis没有拿到值，直接setnx加锁，拿到锁的去访问数据库，没拿到锁的sleep后再get。
  * 但会出现死锁问题，就是拿到锁的进程可能会挂掉。这个可以用锁过期时间解决（如果过期时间短了，再起个线程监控，加时）

* **穿透：**客户端查询的是整个系统中不存在的数据。

  * 布隆过滤器
  * 算法和bitmap可以分开放置，一般是都放在redis

* **雪崩：**大量的key同时失效，间接造成大量的访问到达DB

  > 分为两种情况。时点性的，时点性无关。

  * 时点性无关的可以用随机过期时间解决。但是时点性的这样解决就不合适，比如一批数据就是要求在零点后过期，还用随机过期时间就不合适。ddq
  * 时点相关可以做类似于击穿的解决方案，仍然是第一个进程加锁访问数据库。或者业务层做延时，随机睡个几十毫秒，总之就是尽量不要让访问在同一时刻到达

### redis做分布式锁

setnx
过期时间
多线程（守护线程，延长过期）



实际用zookeeper做分布式锁（既然使用分布式锁了，说明对速度要求不高，更看重一致性）

# 项目

### 项目概况

2核4G 1000QPS



### 灰度怎么做的

为了做A/B test 做了个灰度发布 ，用到了AOP切面，ThreadLocal、ribbon自定义rule



### 网关做了什么

根据微服务的权重去分发流量



### 限流怎么做的

预估用户量，估计个qps，再压测，如果后

根据令牌桶算法做的，令牌桶以固定速率生成令牌，

guava的RateLimiter做的

用context设置个kv,同级过滤器的shouldfilter取到它就不执行



### 限流出现的问题

直接访问网关的地址是不走过滤器的，需要自己配置一层转发测试。

网关限流后`currentContext.setSendZuulResponse(false)`
但是仍然能够返回相应的信息，如何拒绝？

### 分布式理论

**CAP** ：AP是必须要保证的，因此舍弃C的强一致性，保证最终一致性

**BASE理论**：BASE是Basically Availbale（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写

> 基本可用：指分布式系统出现故障时，运行损失部分可用功能，保证核心功能可用，由于不要求强一致性，所以
>
> BASE允许系统存在中间状态(软状态)，不影响系统可用性，（如显示”支付中“，”数据同步中“等状态）。
>
> 最终一致性：一段时间后所有节点数据会达到一致

### 分布式事务怎么做的

首先要说一个**XA**协议，是由Transaction Manager,TM来控制事务的一致性。

**2pc**是由TM向RM发送提交事务的请求，RM执行sql但是不提交，并返回执行的状态。TM只有收到RM全部ok的消息，才会让RM真正提交（否则命令回滚）。
这个方案的问题在于，TM会出现单点故障。二阶段时TM如果挂掉，无法命令RM提交事务，会导致资源阻塞。还有二阶段commit后，如果其中一个执行失败，是无法回滚的。

**3pc**是将2pc的一阶段拆成了2个阶段，首先询问是否可以提交操作，这个阶段是不会占用资源的。
并且3pc的TM/RM都有超时机制，三阶段如果RM没有收到TM的docommit命令，会自行提交



#### **消息队列+事件表**

支付宝callback支付系统后，更新支付流水表，然后新建支付成功事件给插入事件表，此时是待确认状态。
支付系统这边开一个定时任务，查询事件表中待确认的事件给发送到mq，并将状态更新为已发送。

订单系统则监听消息，并更新状态为已接受。再执行本地事务，并将状态改为已处理。

* 建事件可以直接发给消息队列，但是并不能节省多少时间，因为还要等订单系统消费。同时出现bug时需要查两份bug，所以还是选了定时任务发送。
* 消息队列做持久化
* 事件表做成冷热数据
* 虽然前面复杂，但是后面再加上其他的服务，直接根据事件扔进消息队列同步就行



这个方案适用于中小公司，不适合处理大数据。
我们公司是只起了一个定时任务，能cover住高峰期大概5000条数据。



#### LCN

lcn大体上还是分为事务管理和参与方，但是多了个事务发起者角色，在发起方开始执行业务代码前先调用txManager创建事务组，拿到groupid。然后由事务发起方将信息传递给事务参与方，并添加到事务组。最后由TM通知提交或回滚

协调的本质是代理了代理JDBC中Connection的方式实现对本地事务的操作，保持了请求与db的连接，这样才可以通过TXmanager统一协调控制事务。当本地事务提交回滚或者关闭连接时将会执行假操作，该代理的连接将由LCN连接池管理。

**特点**

* 对代码嵌入性低
* 对数据一致性有较高的保障
* 缺陷在于代理的连接需要随事务发起方一同释放连接，增加了连接占用的时间。
* 适合能用JDBC连接的所有支持事务的数据库



#### TCC

相比于传统XA模式，特点在于它不依赖RM对XA的支持，而是通过业务逻辑的调度来实现分布式事务，主要是3步操作try、confirm、cancel。每个事务处理方法可以额外包含confirm、cancel方法，出现问题通过cancel方法将数据还原，相当于手动回滚。

**特点**

* 对代码的嵌入性高，要求每个业务需要写二个以上步骤的操作。
* 可以应用于无本地事务的场景，比如redis，mongodb
* 数据一致性控制几乎完全由开发者控制，较为复杂
* 性能较高，简单的业务可以用（3个sql操作以下）



#### 可靠消息最终一致性方案

由自己开发的可靠消息服务来管理消息，如果处理的业务多，可以叫可靠消息中台
可靠消息服务会存储请求信息，再发送给MQ。

相当于综合了事件表的服务

**特点**

* 适用于时效性不高的服务
* ==优势==是吞吐量大，响应快，可以提高并发量。因为请求过来后，只需要发送待确认消息，操作DB，向中台发送消息，就返回了。后续处理不管，
* 相当于把整条调用链路变成调用单体的单个功能。



#### 事务消息

使用rocketmq的事务消息机制。

provider发送Half Message，executeLocalTransaction中写入要执行的事务，成功则commit，失败则标记状态为unknown，然后broker会调用checkLocalTransaction



回查事务id来确认事务状态
自建事务表





### 分布式锁

#### mysql锁

小项目可以用，高并发对数据库压力较大。

mysql是将一个实体类当做锁，通过主键约束使得只有一个人能够成功插库。





### 如何提高并发量

把整条调用链路变成调用单体的单个功能

比如你下订单以后，后面可能涉及到需要操作，如加积分、走物流、
直接发送到MQ，让后续服务订阅即可。

这样你发送消息后，只需要简单的步骤就可以返回结果（比如点击支付后，显示支付中的状态），可以提高并发量