## 继承



继承是is-a的关系，父类更通用，子类更具体

### 作用

将公共部分提取出来让代码解耦，更加简洁，维护性提升，提高代码的复用性

### 特性

构造方法不能继承，如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。

子类可以用自己的方式实现父类的方法。

### super、this

super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。



调用构造方法时，只能是第一句。

super和this都不能在static方法中、不能同时出现在构造方法中。



## 重写、重载

### 重写(Override)

* 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**

* 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。

* 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。

由于在编译阶段，只是检查参数的引用类型。然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。

~~~java
Animal b = new Dog(); 
//b无法调用dog独有的方法，因为引用类型是Animal，没有该方法
~~~

#### 方法的重写规则

- 父类的成员方法只能被它的子类重写。
- 参数列表与被重写方法的参数列表必须完全相同。
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
- 访问权限不能比父类中被重写的方法的访问权限更严格。
- 声明为 final、static 的方法不能被重写。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。

#### Super 关键字的使用

调用父类的逻辑，同时可以添加新的逻辑



### 重载

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

### 区别

| 区别点   | 重载方法 | 重写方法                                             |
| :------- | :------- | :--------------------------------------------------- |
| 参数列表 | 必须修改 | 一定不能修改                                         |
| 返回类型 | 可以修改 | 一定不能修改                                         |
| 异常     | 可以修改 | 可以减少或删除，<br />一定不能抛出新的或者更广的异常 |
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）               |

### 总结

方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，**重写**是父类与子类之间多态性的一种表现，**重载**可以理解成多态的具体表现形式。

**方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。**



## 多态

### 多态的优点

- 1. 消除类型之间的耦合关系
- 2. 可替换性
- 3. 可扩充性
- 4. 接口性
- 5. 灵活性
- 6. 简化性

### 多态存在的三个必要条件

- 继承
- 重写
- 父类引用指向子类对象

~~~java
Parent p = new Child();
~~~

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。



## 抽象类

由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。

### 抽象方法

抽象方法只包含一个方法名，而没有方法体。

- 如果一个类包含抽象方法，那么该类必须是抽象类。
- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。



## 接口

接口是一种规范
比如cpu可以当成一种接口，它有获得自己cpu信息的方法。而不同的生产厂商实现这个接口，重写方法的信息。PC电脑也实现这个接口，方法区中写入的是Cpu cpu ，通过输入不同厂商的cpu来实现不同的效果。

* 接口中的方法会被隐式的指定为 **public abstract**

* 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量

### 抽象类和接口的区别

- 1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行（1.8后可以）
- 2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。
- 3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
- 4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

## 枚举

每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。

方法：

- values() 返回枚举类中所有的值。
- ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。
- valueOf()方法返回指定字符串值的枚举常量。





# =====================





#### 局部变量与成员变量



成员变量存放于栈内存中、有默认值

局部变量存放于堆内存中、无默认值


### 引用类型

·Java中的对象和数组是通过引用对其操作的.
-引用可以理解为一种受限的指针
指针是可以进行与整数做加减运算的，两个指针之间也可以进行大小比较运算和相减运算。引用不行，只能进行值运算。
引用就是个变量或对象的别名（引用的本质是一个对象）；指针是一个段内存空间的地址（指向存储一个变量值的空间或一个对蒙的空间







### 代码块 *

static > 继承>{} >



### 静态导包

* import static java.lang.Math
  * 之后可以



### 抽象类

用abstract修饰，无法实例化，因为没有意义。

### final

类不希望被继承、方法不希望被重写、属性值不希望被修改

* 



### 接口

接口是一种规范
比如cpu可以当成一种接口，它有获得自己cpu信息的方法。而不同的生产厂商实现这个接口，重写方法的信息。PC电脑也实现这个接口，方法区中写入的是Cpu cpu ，通过输入不同厂商的cpu来实现不同的效果。

### 内部类

* 成员内部类
  * 外部类不能直接使用内部类的成员和方法
  * 内部类默认使用自己的成员变量和方法
    可用this访问外部类的